<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Grid</title>
    <style>
        body {
            background: #eeeeee;
            margin: 0;
            padding: 0;
        }
    </style>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.0/TweenMax.min.js"></script>
    <script src="//d3js.org/queue.v1.min.js"></script>
    <script src="./js/stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
    <script src="./js/utils.js"></script>
    <script src="./js/drawaxis.js"></script>
    <script src="./js/drawgrid.3.js"></script>


    <style>
        html,
        body {
            height: 100%;
        }

        #tooltip {
            position: absolute;
            background: #fff;
            padding: 10px;
            border-radius: 10px;
            display: none;
        }

        #bars,
        #spheres,
        #cubes,
        #planes {
            position: absolute;
            background: #fff;
            padding: 10px;
            border-radius: 10px;
            left: 100px;
            top: 100px;
        }

        #spheres {
            top: 150px;
        }

        #bars {
            top: 200px;
        }

        #planes {
            top: 250px;
        }
    </style>

</head>

<body>
    <div id="tooltip"></div>
    <div id="cubes">cubes</div>
    <div id="spheres">spheres</div>
    <div id="bars">bars</div>
    <div id="planes">planes</div>


    <script>
        const container = document.body;
        const width = window.innerWidth;
        const height = window.innerHeight;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        var cubes = [];
        var curLayout = '';

        var sphereGridGroup = new THREE.Group();
        var barGridGroup = new THREE.Group();
        var cubeGridGroup = new THREE.Group();
        var planeGridGroup = new THREE.Group();

        const cubeAxis = {
            xAxis: 1000,
            yAxis: 400,
            zAxis: 600,
            xgrid: 100,
            ygrid: 100,
            zgrid: 120,
            group: cubeGridGroup
        }
        const sphereAxis = {
            xAxis: 1000,
            yAxis: 600,
            zAxis: 600,
            xgrid: 100,
            ygrid: 100,
            zgrid: 150,
            group: sphereGridGroup
        }
        const barAxis = {
            bandWidth: 6,
            xAxis: 1000,
            group: barGridGroup
        }
        const planeAxis = {
            xAxis: 1000,
            zAxis: 600,
            yAxis: 0,
            ygrid: 0,
            xgrid: 100,
            zgrid: 100,
            group: planeGridGroup
        }

        // 小立方体的边长
        var cubeX;
        var cubeZ;
        var cubeY;
        var maxCount;

        var cubeGeometry;

        var scaleLinearLat;
        var scaleLinearLon;

        var quadrant;

        var curLayoutMap = {};
        var timer;

        const texture = new THREE.TextureLoader().load('./china.jpg');

        var res = []; // 二维数组

        //初始化性能插件
        function initStats() {
            stats = new Stats();
            document.body.appendChild(stats.dom);
        }
        function initOrthCamera() {
            camera = new THREE.PerspectiveCamera(45, width / height, 1, 100000);
            camera.position.set(800, 1500, 1500);//设置相机坐标
            camera.lookAt({ x: 0, y: 0, z: 0 });//让相机指向场景中心
        }

        function initLight() {
            scene.add(new THREE.AmbientLight(0x444444));
            light = new THREE.DirectionalLight(0xffffff);
            light.position.set(15, 50, 10);
            //告诉平行光需要开启阴影投射

            light.castShadow = true;
            scene.add(light);
        }
        function animate() {
            const vector = camera.getWorldDirection(new THREE.Vector3());
            const curquadrant = helperMethods.getQuadrant(0, 0, vector.x, vector.z);
            const curhorquadrant = helperMethods.getQuadrant(0, 0, vector.z, vector.y);
            // console.log(curhorquadrant)
            if (curquadrant !== quadrant) {
                quadrant = curquadrant;
                Object.values(curLayoutMap).forEach(row => row.updateText(quadrant));
            }
            stats.update();
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function init() {
            initStats();
            initOrthCamera();
            scene = new THREE.Scene();      //创建场景  
            scene.translateX(- width / 4);
            scene.translateY(height / 4);
            initLight();
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: false, clearColor: 0x000000 });     //创建渲染器（并设置抗锯齿属性）
            renderer.setSize(width, height);    //设置渲染器的大小
            container.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.screenSpacePanning = true;
            window.addEventListener('resize', function () {
                renderer.setSize(window.innerWidth, window.innerHeight);
                var aspectRatio = window.innerWidth/window.innerHeight;
                camera.aspect = aspectRatio;
                camera.updateProjectionMatrix();
            })
            const vector = camera.getWorldDirection(new THREE.Vector3());
            quadrant = helperMethods.getQuadrant(0, 0, vector.x, vector.z)

            // mousemove事件
            const tooltipPosition = {};
            let intersects = [];
            let INTERSECTED;
            const tooltip = document.getElementById('tooltip');
            document.addEventListener('mousemove', onmouseOver, false);

            function onmouseOver(event) {
                mouse.x = (event.clientX / width) * 2 - 1;
                mouse.y = - (event.clientY / height) * 2 + 1;
                tooltipPosition.x = event.clientX + 'px';
                tooltipPosition.y = event.clientY + 'px';
                getIntersectObjects();
            }
            function getIntersectObjects() {
                raycaster.setFromCamera(mouse, camera);

                intersects = raycaster.intersectObjects(scene.children, true);
                if (intersects.length) {
                    if (intersects[0].object.customType === 'cube' && INTERSECTED !== intersects[0].object) {
                        if (INTERSECTED) INTERSECTED.material.color.set(INTERSECTED.currentColor);
                        INTERSECTED = intersects[0].object;
                        INTERSECTED.currentColor = JSON.parse(JSON.stringify(INTERSECTED.material.color));
                        INTERSECTED.material.color.set(0xff0000);
                        tooltip.innerHTML = INTERSECTED.customName + '-' + INTERSECTED.customLon + '-' + INTERSECTED.customLat;
                        tooltip.style.left = tooltipPosition ? tooltipPosition.x : '';
                        tooltip.style.top = tooltipPosition ? tooltipPosition.y : '';
                        tooltip.style.display = 'block';
                    }
                } else {
                    if (INTERSECTED) INTERSECTED.material.color.set(INTERSECTED.currentColor);
                    tooltip.style.display = 'none';
                }
            }
            queue().defer(d3.csv, "./bank.csv").await(ready);
            animate();
        }

        init();
        function ready(error, data) {
            let temp = {};
            const [minLat, maxLat] = d3.extent(data.map(row => +row.latitude));
            const [minLon, maxLon] = d3.extent(data.map(row => +row.longitude));

            const { xAxis, yAxis, zAxis } = cubeAxis;

            scaleLinearLat = d3.scaleLinear().domain([maxLat, minLat]).range([0, zAxis]);
            scaleLinearLon = d3.scaleLinear().domain([minLon, maxLon]).range([0, xAxis]);
            scaleTime = d3.scaleTime().range([0, 600]).domain((d3.extent(data, function (d) { return new Date(d.date); })))

            const density = 10;
            cubeX = density;
            cubeZ = density;
            for (const item of data) {
                const posX = parseInt(scaleLinearLon(item.longitude) / density);
                const posZ = parseInt(scaleLinearLat(item.latitude) / density);
                let x = (posX - 1) * density + density * 3 / 2;
                let z = (posZ - 1) * density + density * 3 / 2;
                if (x > xAxis - density / 2) {
                    x = x - density;
                }
                if (z > zAxis - density / 2) {
                    z = z - density;
                }
                const centerPos = { x, z };
                item.centerPos = centerPos;
            }
            data.forEach(row => {
                const fixed = JSON.stringify(row.centerPos);
                if (temp[fixed]) {
                    temp[fixed].push(row);
                } else {
                    temp[fixed] = [row];
                }
            })
            Object.values(temp).map(row => res.push(row));
            maxCount = Math.max(...(Object.values(temp).map(row => row.length)));
            cubeY = 400 / maxCount;
            if (cubeY < density) {
                cubeX = cubeZ = cubeY;
            }

            if (cubeY > cubeX) {
                cubeY = cubeX
            }
            for (const item of data) {
                const month = new Date(item.date).getMonth();
                const monthArr = data.filter(row => row.month === month);
                if (!monthArr.length) {
                    item.index = 0;
                } else {
                    const curIndex = Math.max(...(monthArr.map(row => row.index)));
                    item.index = curIndex + 1;
                }
                item.month = month;
            }

            cubeGeometry = new THREE.BoxGeometry(cubeX - 1, cubeY - 1, cubeZ - 1);
            cubesColorScale = d3.scaleLinear().domain([0, maxCount]).range([d3.rgb("#007AFF"), d3.rgb('#ff4300')]);

            cubeAxis.scaleY = d3.scaleLinear().domain([0, maxCount]).range([0, cubeAxis.yAxis]);
            cubeAxis.scaleZ = i => scaleLinearLat.invert(i * cubeAxis.zgrid).toFixed(2);
            cubeAxis.scaleX = i => scaleLinearLon.invert(i * cubeAxis.xgrid).toFixed(2);

            sphereAxis.scaleY = i => moment(scaleTime.invert(i * sphereAxis.ygrid)).format('YYYY-MM-DD hh:mm:ss');
            sphereAxis.scaleZ = i => scaleLinearLat.invert(i * sphereAxis.zgrid).toFixed(2);
            sphereAxis.scaleX = i => scaleLinearLon.invert(i * sphereAxis.xgrid).toFixed(2);

            planeAxis.scaleY = i => '';
            planeAxis.scaleZ = i => scaleLinearLat.invert(i * planeAxis.zgrid).toFixed(2);
            planeAxis.scaleX = i => scaleLinearLon.invert(i * planeAxis.xgrid).toFixed(2);

            barAxis.perCount = Math.ceil(barAxis.xAxis / 12 / cubeX);
            barAxis.xAxis = (barAxis.perCount * cubeX + barAxis.bandWidth) * 12; // 调整xAxis
            barAxis.yAxis = Math.ceil(Math.max(...(data.map(row => row.index))) / barAxis.perCount / barAxis.perCount) * barAxis.perCount * cubeY; // 调整yAxis
            barAxis.ygrid = barAxis.perCount * cubeY;
            barAxis.xgrid = barAxis.perCount * cubeX + barAxis.bandWidth;
            barAxis.zgrid = cubeZ;
            barAxis.zAxis = cubeZ;
            barAxis.scaleY = i => i * barAxis.perCount * barAxis.perCount;
            barAxis.scaleZ = i => '';
            barAxis.scaleX = i => i + 1;

            const cubesButton = document.getElementById('cubes');
            cubesButton.addEventListener('click', () => transform('cubes'), false);
            const spheresButton = document.getElementById('spheres');
            spheresButton.addEventListener('click', () => transform('spheres'), false);
            const barsButton = document.getElementById('bars');
            barsButton.addEventListener('click', () => transform('bars'), false);
            const planesButton = document.getElementById('planes');
            planesButton.addEventListener('click', () => transform('planes'), false);

            curLayoutMap.planes = new PlaneText(planeAxis, quadrant);
            curLayoutMap.cubes = new CubeText(cubeAxis, quadrant);
            curLayoutMap.bars = new BarText(barAxis, quadrant);
            curLayoutMap.spheres = new SphereText(sphereAxis, quadrant);
            function setData(d, i) {
                const { date, longitude, latitude } = data[i];
                const sphere = new THREE.Object3D()
                sphere.position.x = scaleLinearLon(longitude)
                sphere.position.y = scaleTime(new Date(date)) + cubeY
                sphere.position.z = scaleLinearLat(latitude)

                d.spheres = sphere

                const bar = new THREE.Object3D()

                const { perCount, bandWidth } = barAxis;
                bar.position.x = cubes[i].index % perCount * cubeX + cubeX / 2 + cubes[i].month * (cubeX * perCount + bandWidth) + bandWidth / 2
                bar.position.y = ~~(cubes[i].index / perCount) * cubeY + cubeY / 2
                bar.position.z = cubeZ / 2

                d.bars = bar

                const cube = new THREE.Object3D()
                cube.position.x = res[cubes[i].i][cubes[i].j].centerPos.x
                cube.position.y = cubes[i].j * cubeY + cubeY / 2
                cube.position.z = res[cubes[i].i][cubes[i].j].centerPos.z

                d.cubes = cube

                const plane = new THREE.Object3D()
                plane.position.x = scaleLinearLon(res[cubes[i].i][cubes[i].j].longitude)
                plane.position.y = cubeY / 2
                plane.position.z = scaleLinearLat(res[cubes[i].i][cubes[i].j].latitude)

                d.planes = plane
            }
            function transform(layout) {
                if (curLayout === layout) {
                    return;
                } else {
                    Object.values(curLayoutMap).forEach(row => removeText(row.group));
                    const len = cubes.length;
                    const duration = 1000

                    if (timer) {
                        timer.stop()
                    }
                    var tweens = [];
                    cubes.forEach(d => {
                        const { position, rotation } = d;
                        const ip = d3.interpolateArray(
                            position.toArray(),
                            d[layout].position.toArray(),
                        )
                        tweens.push(function chartTween(t) {
                            position.set(...ip(t))
                        })
                    })
                    const count = tweens.length

                    timer = d3.timer(function tweenCharts(t) {
                        const p = Math.min(t / duration, 1)

                        for (let i = 0; i < count; i++) {
                            tweens[i](p)
                        }

                        renderer.render(scene, camera)

                        if (t > duration) {
                            timer.stop()
                            showText(curLayoutMap[layout].group);
                            renderer.render(scene, camera)
                        }
                    })
                    curLayout = layout;
                }
            }
            function initCube(item, i, j) {
                const material = new THREE.MeshLambertMaterial({
                    color: '#57f972',
                    transparent: true
                });
                cube1 = new THREE.Mesh(cubeGeometry, material);
                cube1.customType = 'cube';
                cube1.customName = item.date;
                cube1.customLat = item.latitude;
                cube1.customLon = item.longitude;
                item.centerPos.y = j * cubeY + cubeY / 2;

                var helper = new THREE.BoxHelper(cube1);
                helper.material.color.set(0x0be064);

                const cubeGroup = new THREE.Object3D();
                cubeGroup.add(cube1, helper);
                // cubeGroup.position.z = item.centerPos.z;
                // cubeGroup.position.x = item.centerPos.x;
                // cubeGroup.position.z = scaleLinearLat(item.latitude);
                // cubeGroup.position.x = scaleLinearLon(item.longitude);
                // cubeGroup.position.y = cubeY / 2;
                cubeGroup.position.z = Math.random() * zAxis / 2 + zAxis / 2;
                cubeGroup.position.x = Math.random() * xAxis / 2 + xAxis / 2;
                cubeGroup.position.y = cubeY / 2;

                cubeGroup.i = i;
                cubeGroup.j = j;
                cubeGroup.month = item.month;
                cubeGroup.index = item.index;
                cubes.push(cubeGroup);
                scene.add(cubeGroup);
            }
            function initCubes() {
                const resLen = res.length;
                for (let i = 0; i < resLen; i++) {
                    for (let j = 0; j < res[i].length; j++) {
                        initCube(res[i][j], i, j);
                    }
                }
            }

            initCubes();
            cubes.forEach(setData);
            transform('cubes');
        }
    </script>
</body>

</html>