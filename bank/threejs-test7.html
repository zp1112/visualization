<!doctype html>  
<html>  
    <head>  
        <meta charset="utf-8"/>  
        <title>Grid</title>  
        <style>body{background:#eeeeee;margin:0;padding:0;}</style>  
        <script src="https://d3js.org/d3.v4.min.js"></script>
        <script src="https://threejs.org/build/three.js"></script>  
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.0/TweenMax.min.js"></script>
        <script src="//d3js.org/queue.v1.min.js"></script>
        <script src="https://www.wjceo.com/lib/js/libs/stats.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
        <script src="./js/utils.js"></script>
        <script src="./js/drawaxis.js"></script>
        <script src="./js/drawgrid.3.js"></script>
        

        <style>
            html, body {
                height: 100%;
            }
            #tooltip {
                position: absolute;
                background: #fff;
                padding: 10px;
                border-radius: 10px;
                display: none;
            }
            #bars, #spheres, #cubes, #planes {
                position: absolute;
                background: #fff;
                padding: 10px;
                border-radius: 10px;
                left: 100px;
                top: 100px;
            }
            #spheres {
                top: 150px;
            }
            #bars {
                top: 200px;
            }
            #planes {
                top: 250px;
            }
        </style>
        
    </head>  
    <body>  
        <div id="tooltip"></div>
        <div id="cubes">cubes</div>
        <div id="spheres">spheres</div>
        <div id="bars">bars</div>
        <div id="planes">planes</div>


        <script>
        const container = document.body;
        const width = window.innerWidth;  
        const height = window.innerHeight;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        var cubes = [];
        var curType = '';

        var sphereGridGroup = new THREE.Group();
        var barGridGroup = new THREE.Group();
        var cubeGridGroup = new THREE.Group();
        var planeGridGroup = new THREE.Group();

        const cubeAxis = {
            xAxis: 1000,
            yAxis: 400,
            zAxis: 600,
            xgrid: 100,
            ygrid: 100,
            zgrid: 120,
            group: cubeGridGroup
        }
        const sphereAxis = {
            xAxis: 1000,
            yAxis: 600,
            zAxis: 600,
            xgrid: 100,
            ygrid: 100,
            zgrid: 150,
            group: sphereGridGroup
        }
        const barAxis = {
            bandWidth: 6,
            xAxis: 1000,
            group: barGridGroup
        }
        const planeAxis = {
            xAxis: 1000,
            zAxis: 600,
            yAxis: 0,
            ygrid: 0,
            xgrid: 100,
            zgrid: 100,
            group: planeGridGroup
        }

        // 小立方体的边长
        var cubeX;
        var cubeZ;
        var cubeY;
        var maxCount;

        var cubeGeometry;

        var scaleLinearLat;
        var scaleLinearLon;

        var quadrant;

        var curTypeMap = {};

        const texture = new THREE.TextureLoader().load( './china.jpg' );

        var res = []; // 二维数组

        //初始化性能插件
        function initStats() {
            stats = new Stats();
            document.body.appendChild(stats.dom);
        }
        function initOrthCamera(){
            camera = new THREE.PerspectiveCamera(45, width/height, 1, 100000);
            camera.position.set(800,1500, 1500);//设置相机坐标
            camera.lookAt({x: 0, y: 0, z: 0});//让相机指向场景中心
        }

        function initLight() {
            scene.add(new THREE.AmbientLight(0x444444));
            light = new THREE.DirectionalLight(0xffffff);
            light.position.set(15,50,10);
            //告诉平行光需要开启阴影投射

            light.castShadow = true;
            scene.add(light);
        }
        function animate() {
            const vector = camera.getWorldDirection(new THREE.Vector3());
            const curquadrant = getQuadrant(0, 0, vector.x,vector.z)
            if (curquadrant !== quadrant) {
                quadrant = curquadrant;
                console.log(quadrant)
                Object.values(curTypeMap).forEach(row => row.updateText(quadrant));
            }
            stats.update();
            requestAnimationFrame( animate );
            renderer.render(scene, camera);
        }

        function init() {
            initStats();
            initOrthCamera();
            scene = new THREE.Scene();      //创建场景  
            scene.background = new THREE.Color( 0x000000 );
            scene.translateX(- width / 4);
            scene.translateY(height / 4);
            initLight();
            renderer = new THREE.WebGLRenderer({antialias : true, logarithmicDepthBuffer: true});     //创建渲染器（并设置抗锯齿属性）
            renderer.setSize(width, height);    //设置渲染器的大小
            container.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.screenSpacePanning = true;
            window.addEventListener('resize', function(){
                renderer.setSize(window.innerWidth, window.innerHeight);
            })
            const vector = camera.getWorldDirection(new THREE.Vector3());
            quadrant = getQuadrant(0, 0, vector.x,vector.z)
            
            // mousemove事件
            const tooltipPosition = {};
            let intersects = [];
            let INTERSECTED;
            const tooltip = document.getElementById('tooltip');
            document.addEventListener('mousemove', onmouseOver, false);

            function onmouseOver(event) {
                mouse.x = ( event.clientX / width ) * 2 - 1;
                mouse.y = - ( event.clientY / height ) * 2 + 1;
                tooltipPosition.x = event.clientX + 'px';
                tooltipPosition.y = event.clientY + 'px';
                getIntersectObjects();
            }
            function getIntersectObjects() {
                raycaster.setFromCamera(mouse, camera);

                intersects = raycaster.intersectObjects(scene.children, true);
                if (intersects.length) {
                    if (intersects[0].object.customType === 'cube' && INTERSECTED !== intersects[0].object) {
                        if (INTERSECTED) INTERSECTED.material.color.set( INTERSECTED.currentColor );
                        INTERSECTED = intersects[0].object;
                        INTERSECTED.currentColor = JSON.parse(JSON.stringify(INTERSECTED.material.color));
                        INTERSECTED.material.color.set( 0xff0000 );
                        tooltip.innerHTML = INTERSECTED.customName + '-' + INTERSECTED.customLon + '-' + INTERSECTED.customLat;
                        tooltip.style.left = tooltipPosition ? tooltipPosition.x : '';
                        tooltip.style.top = tooltipPosition ? tooltipPosition.y : '';
                        tooltip.style.display = 'block';
                    }
                } else {
                    if (INTERSECTED) INTERSECTED.material.color.set( INTERSECTED.currentColor );
                        tooltip.style.display = 'none';
                }
            }
            queue().defer(d3.csv, "./bank.csv").await(ready);
            animate(); 
        }

        init();
        function ready(error, data) {
            let temp = {};
            const maxLat = Math.max(...(data.map(row => row.latitude)));
            const minLat = Math.min(...(data.map(row => row.latitude)));
            const maxLon = Math.max(...(data.map(row => row.longitude)));
            const minLon = Math.min(...(data.map(row => row.longitude)));
            scaleLinearLat = d3.scaleLinear().domain([maxLat, minLat]).range([0, cubeAxis.zAxis]);
            scaleLinearLon = d3.scaleLinear().domain([minLon, maxLon]).range([0, cubeAxis.xAxis]);
            scaleTime = d3.scaleTime().range([0, 600]).domain((d3.extent(data, function(d) { return new Date(d.date); })))

            const { xAxis, yAxis, zAxis } = cubeAxis;
            const density = 10;
            cubeX = density;
            cubeZ = density;
            for (const item of data) {
                const posX = parseInt(scaleLinearLon(item.longitude) / density);
                const posZ = parseInt(scaleLinearLat(item.latitude) / density);
                let x = (posX - 1) * density + density * 3 / 2;
                let z = (posZ - 1) * density + density * 3 / 2;
                if (x > xAxis - density / 2) {
                    x = x - density;
                }
                if (z > zAxis - density / 2) {
                    z = z - density;
                }
                const centerPos = { x, z };
                item.centerPos = centerPos;
            }
            data.forEach(row => {
                const fixed = JSON.stringify(row.centerPos);
                if (temp[fixed]) {
                    temp[fixed].push(row);
                } else {
                    temp[fixed] = [row];
                }
            })
            Object.values(temp).map(row => res.push(row));
            maxCount = Math.max(...(Object.values(temp).map(row => row.length)));
            cubeY = 400 / maxCount;
            if (cubeY < density) {
                cubeX = cubeZ = cubeY;
            }

            if (cubeY > cubeX) {
                cubeY = cubeX
            }
            for (const item of data) {
                const month = new Date(item.date).getMonth();
                const monthArr = data.filter(row => row.month === month);
                if (!monthArr.length) {
                    item.index = 0;
                } else {
                    const curIndex = Math.max(...(monthArr.map(row => row.index)));
                    item.index = curIndex + 1;
                }
                item.month = month;
            }

            cubeGeometry = new THREE.BoxGeometry(cubeX, cubeY, cubeZ);
            cubesColorScale = d3.scaleLinear().domain([0, maxCount]).range([d3.rgb("#007AFF"), d3.rgb('#ff4300')]);

            cubeAxis.scaleY = d3.scaleLinear().domain([0, maxCount]).range([0, cubeAxis.yAxis]);
            cubeAxis.scaleZ = i => scaleLinearLat.invert(i * cubeAxis.zgrid).toFixed(2);
            cubeAxis.scaleX = i => scaleLinearLon.invert(i * cubeAxis.xgrid).toFixed(2);

            sphereAxis.scaleY = i => moment(scaleTime.invert(i * sphereAxis.ygrid)).format('YYYY-MM-DD hh:mm:ss');
            sphereAxis.scaleZ = i => scaleLinearLat.invert(i * sphereAxis.zgrid).toFixed(2);
            sphereAxis.scaleX = i => scaleLinearLon.invert(i * sphereAxis.xgrid).toFixed(2);

            planeAxis.scaleY = i => '';
            planeAxis.scaleZ = i => scaleLinearLat.invert(i * planeAxis.zgrid).toFixed(2);
            planeAxis.scaleX = i => scaleLinearLon.invert(i * planeAxis.xgrid).toFixed(2);

            barAxis.perCount = Math.ceil(barAxis.xAxis / 12 / cubeX);
            barAxis.xAxis = (barAxis.perCount * cubeX + barAxis.bandWidth) * 12; // 调整xAxis
            barAxis.yAxis = Math.ceil(Math.max(...(data.map(row => row.index))) / barAxis.perCount / barAxis.perCount) * barAxis.perCount * cubeY; // 调整yAxis
            barAxis.ygrid = barAxis.perCount * cubeY;
            barAxis.xgrid = barAxis.perCount * cubeX + barAxis.bandWidth;
            barAxis.zgrid = cubeZ;
            barAxis.zAxis = cubeZ;
            barAxis.scaleY = i => i * barAxis.perCount * barAxis.perCount;
            barAxis.scaleZ = i => '';
            barAxis.scaleX = i => i + 1;

            const cubesButton = document.getElementById('cubes');
            cubesButton.addEventListener('click', () => transGroup('cubes'), false);
            const spheresButton = document.getElementById('spheres');
            spheresButton.addEventListener('click', () => transGroup('spheres'), false);
            const barsButton = document.getElementById('bars');
            barsButton.addEventListener('click', () => transGroup('bars'), false);
            const planesButton = document.getElementById('planes');
            planesButton.addEventListener('click', () => transGroup('planes'), false);

            curTypeMap.planes = new PlaneText(planeAxis, quadrant);
            curTypeMap.cubes = new CubeText(cubeAxis, quadrant);
            curTypeMap.bars = new BarText(barAxis, quadrant);
            curTypeMap.spheres = new SphereText(sphereAxis, quadrant);

            function transGroup(to) {
                if (curType === to) {
                    return;
                } else {
                    removeText(cubeGridGroup);
                    removeText(barGridGroup);
                    removeText(sphereGridGroup);
                    removeText(planeGridGroup);
                    const len = cubes.length;
                    let count = 0;
                    if (to === 'spheres') {
                        for(let i = 0; i < len; i ++) {
                            const { date, longitude, latitude } = data[i];
                            new TweenMax.to(cubes[i].position, 1, {
                                y: scaleTime(new Date(date)) + cubeY,
                                z: scaleLinearLat(latitude),
                                x: scaleLinearLon(longitude),
                                onComplete: () => {
                                    count += 1;
                                    if (count === len) {
                                        showText(sphereGridGroup);
                                    }
                                }
                            });
                        }
                    } else if(to === 'bars') {
                        const { perCount, bandWidth } = barAxis;
                        for(let i = 0; i < len; i ++) {
                            new TweenMax.to(cubes[i].position, 1, {
                                y: ~~(cubes[i].index / perCount) * cubeY + cubeY / 2,
                                z: cubeZ / 2,
                                x: cubes[i].index % perCount * cubeX + cubeX / 2 + cubes[i].month * (cubeX * perCount + bandWidth) + bandWidth / 2,
                                onComplete: () => {
                                    count += 1;
                                    if (count === len) {
                                        showText(barGridGroup);
                                    }
                                }
                            });
                        }
                    } else if (to === 'planes') {
                        for(let i = 0; i < len; i ++) {
                            const { date, longitude, latitude } = data[i];
                            new TweenMax.to(cubes[i].position, 1, {
                                y: cubeY / 2,
                                z: scaleLinearLat(res[cubes[i].i][cubes[i].j].latitude),
                                x: scaleLinearLon(res[cubes[i].i][cubes[i].j].longitude),
                                onComplete: () => {
                                    count += 1;
                                    if (count === len) {
                                        showText(planeGridGroup);
                                    }
                                }
                            });
                        }
                    } else {
                        for(let i = 0; i < len; i ++) {
                            new TweenMax.to(cubes[i].position, 1, {
                                y: cubes[i].j * cubeY + cubeY / 2,
                                z: res[cubes[i].i][cubes[i].j].centerPos.z,
                                x: res[cubes[i].i][cubes[i].j].centerPos.x,
                                onComplete: () => {
                                    count += 1;
                                    if (count === len) {
                                        showText(cubeGridGroup);
                                    }
                                }
                            });
                        }
                    }
                    curType = to;
                }
            }
            function initCube(item, i, j) {
                const material = new THREE.MeshLambertMaterial({
                    color: '#57f972',
                    transparent: true
                });
                cube1 = new THREE.Mesh(cubeGeometry, material);
                cube1.customType = 'cube';
                cube1.customName = item.date;
                cube1.customLat = item.latitude;
                cube1.customLon = item.longitude;
                item.centerPos.y = j * cubeY + cubeY / 2;

                var helper = new THREE.BoxHelper( cube1 );
                helper.material.color.set( 0x0be064 );

                const cubeGroup = new THREE.Object3D();
                cubeGroup.add(cube1, helper);
                // cubeGroup.position.z = item.centerPos.z;
                // cubeGroup.position.x = item.centerPos.x;
                cubeGroup.position.z = scaleLinearLat(item.latitude);
                cubeGroup.position.x = scaleLinearLon(item.longitude);
                cubeGroup.position.y = cubeY / 2;

                cubeGroup.i = i;
                cubeGroup.j = j;
                cubeGroup.month = item.month;
                cubeGroup.index = item.index;
                cubes.push(cubeGroup);
                scene.add(cubeGroup);
            }
            function initCubes() {
                const resLen = res.length;
                for (let i = 0; i < resLen; i ++) {
                    for (let j = 0; j < res[i].length; j ++) {
                        initCube(res[i][j], i, j);
                    }
                }
                curType = 'planes';
                showText(planeGridGroup)
            }
            
            initCubes();
        }


        </script>  
    </body>  
</html>  