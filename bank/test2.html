<html>

<head>
    <title>Three js Line</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-array.v1.min.js"></script>
    <script src="https://d3js.org/d3-geo.v1.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
    <script src="./js/three.min.js"></script>
    <script src="./js/TrackballControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/1.6.20/topojson.min.js"></script>
    <script src="./js/d3threeD.js"></script>
    <script src="./js/PinchZoomControls.js"></script>
    <script src="./js/Projector.js"></script>
    <script src="./js/jquery-3.1.1.min.js"></script>
</head>

<body>
    <div id="view_switch_flat">平面</div>
    <div id="view_switch_spherical">球面</div>
    <script>
        THREE.Vector3.prototype.mix = function(v2, factor) {
            this.x = this.x + (v2.x - this.x) * factor;
            this.y = this.y + (v2.y - this.y) * factor;
            this.z = this.z + (v2.z - this.z) * factor;
        };
        var projection = d3.geoRobinson();
        var path = d3.geoPath().projection(projection);

        var viewMode = '2d';
        var mouse = new THREE.Vector2();
        var mouseNormalized = new THREE.Vector3( 0, 0, 1 );
        var raycaster = new THREE.Raycaster();
        var intersectedObject;
        var countryBorder;
        var introRunning = true;

        let _d3threeD = {};
        d3threeD(_d3threeD);
        transformSVGPath = _d3threeD.transformSVGPath;

        var dataCountries, countriesObject3D, scene, bufferGeometry, controlsTrackball, controls, countriesObject3D;
        var countries = [];
        var geometryNeedsUpdate = false;
        var trianglesNumTotal = 0;
        var Config = {
            cameraDistance: 500,
            cameraDistanceMin: 30,
            cameraDistanceMax: 10000,
            cameraDistanceMin2D: 30,
            globeRotationX: -2.25,
            globeRotationY: 1.7,
            globeRadius: 180,
            introRotateDuration: 4000,
            introWarpDelay: 2000,
            introWarpDuration: 2500,
            viewSwitchDuration: 800,
            materialCountryBorder: new THREE.LineBasicMaterial( { color: 0xFFFFFF, linewidth: 1.5 } ),
            mapOffsetX: -540, // -500
            mapOffsetY: 200, // 160
        }
        var animationProps = {
            interpolatePos: 0.0,
            lineAnimatePos: 0.0,
            lineAnimateOffset: 0.0,
            colorChangeID: 0
        };
        var inited;
        function initControls() {
            controlsTrackball = new THREE.TrackballControls( camera, renderer.domElement );
            controlsTrackball.rotateSpeed = 0.5; // 1.0
            controlsTrackball.zoomSpeed = 1.0;
            controlsTrackball.panSpeed = 0.25;

            controlsTrackball.noRotate = false;
            controlsTrackball.noZoom = false;
            controlsTrackball.noPan = true;

            controlsTrackball.staticMoving = false;
            controlsTrackball.dynamicDampingFactor = 0.2;

            controlsTrackball.minDistance = Config.cameraDistanceMin;
            controlsTrackball.maxDistance = Config.cameraDistanceMax;

            controlsTrackball.keys = []; // [ 65 // A, 83 // S, 68 // D ]; // [ rotateKey, zoomKey, panKey ]
            controlsTrackball.enabled = false;

            controlsPinchZoom = new THREE.PinchZoomControls( camera, renderer.domElement );
            controlsPinchZoom.staticMoving = true;
            controlsPinchZoom.minDistance = Config.cameraDistanceMin2D;
            controlsPinchZoom.maxDistance = Config.cameraDistanceMax;
            controlsPinchZoom.enabled = false;

            controls = controlsPinchZoom;

        }
        init = async() => {
            const fov = 60;
            const aspect = window.innerWidth / window.innerHeight;
            const near = 0.1;
            const far = 20000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		    camera.position.set(0, 0, Config.cameraDistance);
            camera.lookAt({ x: 0, y: 0, z: 0 });//让相机指向场景中心

            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: false });     //创建渲染器（并设置抗锯齿属性）
            renderer.setSize(window.innerWidth, window.innerHeight);    //设置渲染器的大小
            document.body.appendChild(renderer.domElement);
            initControls();
            scene = new THREE.Scene();
            scene.add( new THREE.AmbientLight( 0xffffff ) );
            pointLight = new THREE.PointLight(0x000000);
            pointLight.position.x = 0.0;
            pointLight.position.y = 500.0;
            pointLight.position.z = 1000.0;
            pointLight.intensity = 1.0;
            scene.add(pointLight);

            d3.json('./geo/country_data.json', function(error, data) {
                dataCountries = data;
                completeInit();
            })
            function animate() {
                if (!introRunning) {
                    var intersects = getIntersects();
                    if( intersects.length > 0 ) {
                        if( intersectedObject !== intersects[ 0 ].object) {
                            clearCountryHover();
                            if(intersects[ 0 ].object.name !== 'sphere') {
                                intersectedObject = intersects[ 0 ].object;
                            }
                            var country = intersects[ 0 ].object.countryObject;
                            updateCountryHover(country);
                        }

                    }
                }
                if(geometryNeedsUpdate) {
                    updateCountriesGeometry();
                    updateCountriesBufferGeometry();
                }
            }

            render();
            function render() {
                requestAnimationFrame(render);
                if (inited) {
                    geometryNeedsUpdate = false;
                }
                controls.update();
                TWEEN.update();
                if (inited) {
                    animate();
                }
                renderer.render(scene, camera);
            }
        }
        function completeInit() {
            createCountries();
            document.body.addEventListener('mousemove', onMouseMove);
        }
        init();
        function clearCountryHover() {
            if(countryBorder) {
                scene.remove(countryBorder);
                countryBorder = null;
            }
            if(intersectedObject !== undefined && intersectedObject !== null) {
                if(intersectedObject.countryObject.listItem !== undefined) intersectedObject.countryObject.listItem.removeClass('hover');
            }
            intersectedObject = null;
        }
        function updateCountryHover(country) {
            intersectedObject = country.mesh;

            if(countryBorder) {
                scene.remove(countryBorder);
            }

            if(viewMode === '3d') {
                countryBorder = country.border3D;
            } else {
                countryBorder = country.border2D;
            }
            scene.add(countryBorder);
        }
        
        function onMouseMove(event) {
            event.preventDefault();

            mouse.x = event.clientX;
            mouse.y = event.clientY;

            var viewportWidth = $(window).width();
            var viewportHeight = $(window).height();

            mouseNormalized.x = ( event.clientX / viewportWidth ) * 2 - 1;
            mouseNormalized.y = -( event.clientY / viewportHeight ) * 2 + 1;
        }
        function getIntersects() {
            raycaster.setFromCamera(mouseNormalized, camera);

            var intersects = raycaster.intersectObjects(countriesObject3D.children);

            return intersects;
        }
        function createCountries() {
            inited = true;
            animationProps.interpolatePos = 1.0;
            createCountriesGeometry();
            updateCountriesGeometry(true);
            createCountriesBufferGeometry();
            updateCountriesBufferGeometry();
            window.setTimeout(function() {
                var scaleFinal = 1.0; // has to be one for the picking to work properly in combination with buffer geometry
                tweenScale = new TWEEN.Tween(countriesObject3D.scale)
                    .to({x: scaleFinal, y: scaleFinal, z: scaleFinal}, Config.introRotateDuration) // 3500
                    .delay(0)
                    .onUpdate(function() {
                        geometryNeedsUpdate = true;
                    })
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                tweenWarp = new TWEEN.Tween(animationProps)
                    .to({interpolatePos: 0.0}, Config.introWarpDuration)
                    .delay(Config.introWarpDelay)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .onStart(function() {
                    })
                    .onUpdate(function() {
                        geometryNeedsUpdate = true;
                    })
                    .onComplete(function() {
                        geometryNeedsUpdate = true;
                        introRunning = false;
                        controls.enabled = true;
                    }).start();

                tweenRotation = new TWEEN.Tween(countriesObject3D.rotation)
                    .to({ _y: 0 }, Config.introRotateDuration) // 3500
                    .delay(0)
                    .easing(TWEEN.Easing.Quintic.Out)
                    .onUpdate(function() {
                        geometryNeedsUpdate = true;
                    })
                    .start();
            }, 100);

        }
        function createCountriesGeometry() {
            countriesObject3D = new THREE.Object3D();
            countries = [];

            var m = new THREE.Matrix4();
            var m1 = new THREE.Matrix4();
            var m2 = new THREE.Matrix4();
            m1.makeRotationX( Config.globeRotationX );
            m2.makeRotationY( Config.globeRotationY );
            m.multiplyMatrices( m1, m2 );

            for(i = 0; i < dataCountries.features.length; i++) {
                var feature = dataCountries.features[i];

                if(feature.properties.NAME !== 'Antarctica') { //  && feature.properties.name === 'Germany'
                // convert SVG data to three.js Shapes array (all shapes in one country):
                    var t = path(feature);

                    if(t !== undefined) {
                        var shapes = transformSVGPath( t );
                        var country = {
                            name: feature.properties.NAME_LONG,
                            properties: feature.properties,
                            shapes,
                            color: new THREE.Color(0x777777),
                            colorLast: new THREE.Color(0x777777)
                        };

                        countries.push(country);
                    }
                }
            }
            for(i = 0; i < countries.length; i++) {
                countries[i].geometry = new THREE.ShapeGeometry( countries[i].shapes );

                countries[i].geometry2D = countries[i].geometry.clone();
                for(k = 0; k < countries[i].geometry2D.vertices.length; k++) {
                    countries[i].geometry2D.vertices[k].x += -540;
                    countries[i].geometry2D.vertices[k].y = -countries[i].geometry2D.vertices[k].y + 200;
                }
                trianglesNumTotal += countries[i].geometry.faces.length;

                countries[i].border2D = new THREE.Object3D();
                for(var s = 0; s < countries[i].shapes.length; s++) {
                    var pointsGeometry = countries[i].shapes[s].createPointsGeometry();
                    for(k = 0; k < pointsGeometry.vertices.length; k++) {
                        pointsGeometry.vertices[k].x += Config.mapOffsetX;
                        pointsGeometry.vertices[k].y = -pointsGeometry.vertices[k].y + Config.mapOffsetY;
                        pointsGeometry.vertices[k].z += 0.1;
                    }
                    countries[i].border2D.add(new THREE.Line( pointsGeometry, Config.materialCountryBorder ));
                }

                countries[i].geometry3D = countries[i].geometry.clone();
                for(k = 0; k < countries[i].geometry.vertices.length; k++) {
                    var spherical = projection.invert([countries[i].geometry.vertices[k].x, countries[i].geometry.vertices[k].y]);
                    spherical[0] = THREE.Math.degToRad(spherical[0]);
                    spherical[1] = THREE.Math.degToRad(spherical[1]);

                    countries[i].geometry3D.vertices[k].x = Config.globeRadius * Math.cos(spherical[0]) * Math.cos(spherical[1]);
                    countries[i].geometry3D.vertices[k].y = -Config.globeRadius * Math.sin(spherical[1]);
                    countries[i].geometry3D.vertices[k].z = Config.globeRadius * Math.sin(spherical[0]) * Math.cos(spherical[1]);
                    countries[i].geometry3D.vertices[k].multiplyScalar(1.002);
                }

                countries[i].geometry3D.applyMatrix(m);

                countries[i].border3D = new THREE.Object3D();
                for(s = 0; s < countries[i].shapes.length; s++) {
                    pointsGeometry = countries[i].shapes[s].createPointsGeometry();
                    for(k = 0; k < pointsGeometry.vertices.length; k++) {
                        spherical = projection.invert([pointsGeometry.vertices[k].x, pointsGeometry.vertices[k].y]);

                        spherical[0] = THREE.Math.degToRad(spherical[0]);
                        spherical[1] = THREE.Math.degToRad(spherical[1]);

                        pointsGeometry.vertices[k].x = Config.globeRadius * Math.cos(spherical[0]) * Math.cos(spherical[1]);
                        pointsGeometry.vertices[k].y = -Config.globeRadius * Math.sin(spherical[1]);
                        pointsGeometry.vertices[k].z = Config.globeRadius * Math.sin(spherical[0]) * Math.cos(spherical[1]);

                        pointsGeometry.vertices[k].multiplyScalar(1.001); // 1.004
                    }
                    countries[i].border3D.add(new THREE.Line( pointsGeometry, Config.materialCountryBorder ));
                }
                // rotate and bake transform into vertices:
                countries[i].border3D.applyMatrix(m);
                
                countries[i].mesh = new THREE.Mesh(countries[i].geometry, new THREE.MeshPhongMaterial({
                    color: 0x777777,
                    side: THREE.DoubleSide
                }));
                countries[i].mesh.countryObject = countries[i];
                countriesObject3D.add(countries[i].mesh);
            }
            
            var scaleStart = 0.0;
            countriesObject3D.scale.set(scaleStart, scaleStart, scaleStart);
            countriesObject3D.rotation._y = -Math.PI * 6; // 不知道为什么要使用_y
        }
        function updateCountriesGeometry(computeFaceNormals = false) {
            var i;
            var k;
            for(i = 0; i < countries.length; i++) {
                for(k = 0; k < countries[i].geometry.vertices.length; k++) {
                    countries[i].geometry.vertices[k].copy(countries[i].geometry2D.vertices[k]);
                    countries[i].geometry.vertices[k].mix(countries[i].geometry3D.vertices[k], animationProps.interpolatePos);
                }
                countries[i].geometry.computeBoundingSphere(); // required for picking to work after updating vertices
                if(computeFaceNormals) countries[i].geometry.computeFaceNormals(); // required for shading to look correct
            }
        }
        function createCountriesBufferGeometry() {
            bufferGeometry = new THREE.BufferGeometry();
            var positions = new Float32Array( trianglesNumTotal * 3 * 3 );
            var normals = new Float32Array( trianglesNumTotal * 3 * 3 );
            var colors = new Float32Array( trianglesNumTotal * 3 * 3 );

            var color = new THREE.Color(0x777777);

            var index = 0;
            var i, f;
            for(i = 0; i < countries.length; i++) {
                var vertices = countries[i].geometry.vertices;

                for(f = 0; f < countries[i].geometry.faces.length; f++) {
                var face = countries[i].geometry.faces[f];

                // positions

                positions[ index ] = vertices[ face.a ].x;
                positions[ index + 1 ] = vertices[ face.a ].y;
                positions[ index + 2 ] = vertices[ face.a ].z;

                positions[ index + 3 ] = vertices[ face.b ].x;
                positions[ index + 4 ] = vertices[ face.b ].y;
                positions[ index + 5 ] = vertices[ face.b ].z;

                positions[ index + 6 ] = vertices[ face.c ].x;
                positions[ index + 7 ] = vertices[ face.c ].y;
                positions[ index + 8 ] = vertices[ face.c ].z;

                // normals

                normals[ index ] = face.normal.x;
                normals[ index + 1 ] = face.normal.y;
                normals[ index + 2 ] = face.normal.z;

                normals[ index + 3 ] = face.normal.x;
                normals[ index + 4 ] = face.normal.y;
                normals[ index + 5 ] = face.normal.z;

                normals[ index + 6 ] = face.normal.x;
                normals[ index + 7 ] = face.normal.y;
                normals[ index + 8 ] = face.normal.z;

                // colors

                colors[ index ] = color.r;
                colors[ index + 1 ] = color.g;
                colors[ index + 2 ] = color.b;

                colors[ index + 3 ] = color.r;
                colors[ index + 4 ] = color.g;
                colors[ index + 5 ] = color.b;

                colors[ index + 6 ] = color.r;
                colors[ index + 7 ] = color.g;
                colors[ index + 8 ] = color.b;

                index += 9;

                }
            } // for countries.length buffer geometry creation end

            bufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
            bufferGeometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
            bufferGeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

            bufferGeometry.verticesNeedUpdate = true;
            bufferGeometry.computeBoundingSphere();

            var mesh = new THREE.Mesh(bufferGeometry, 
            new THREE.MeshPhongMaterial( { color: 0xFFFFFF, specular: 0xFFFFFF, shininess: 5, 
                transparent: true, opacity: 0.9, side: THREE.DoubleSide, vertexColors: THREE.VertexColors } ));
            scene.add( mesh );
        };

        function updateCountriesBufferGeometry() {
            var positions = bufferGeometry.getAttribute( 'position' ).array;
            var normals = bufferGeometry.getAttribute( 'normal' ).array;
            var colors = bufferGeometry.getAttribute( 'color' ).array;

            var m = new THREE.Matrix4();
            var m1 = new THREE.Matrix4();
            var m2 = new THREE.Matrix4();
            m1.makeRotationY( countriesObject3D.rotation._y );
            m2.makeScale( countriesObject3D.scale.x, countriesObject3D.scale.y, countriesObject3D.scale.z );
            m.multiplyMatrices( m1, m2 );

            var color = new THREE.Color();
            var v = new THREE.Vector3();

            var index = 0;
            var i, f;
            for(i = 0; i < countries.length; i++) {
                var vertices = countries[i].geometry.vertices;

                color.set(countries[i].color);

                for(f = 0; f < countries[i].geometry.faces.length; f++) {
                var face = countries[i].geometry.faces[f];

                // positions

                v.copy( vertices[ face.a ] );
                v.applyMatrix4(m);

                positions[ index ] = v.x;
                positions[ index + 1 ] = v.y;
                positions[ index + 2 ] = v.z;

                v.copy( vertices[ face.b ] );
                v.applyMatrix4(m);

                positions[ index + 3 ] = v.x;
                positions[ index + 4 ] = v.y;
                positions[ index + 5 ] = v.z;

                v.copy( vertices[ face.c ] );
                v.applyMatrix4(m);

                positions[ index + 6 ] = v.x;
                positions[ index + 7 ] = v.y;
                positions[ index + 8 ] = v.z;

                // normals

                normals[ index ] = face.normal.x;
                normals[ index + 1 ] = face.normal.y;
                normals[ index + 2 ] = face.normal.z;

                normals[ index + 3 ] = face.normal.x;
                normals[ index + 4 ] = face.normal.y;
                normals[ index + 5 ] = face.normal.z;

                normals[ index + 6 ] = face.normal.x;
                normals[ index + 7 ] = face.normal.y;
                normals[ index + 8 ] = face.normal.z;

                // colors

                colors[ index ] = color.r;
                colors[ index + 1 ] = color.g;
                colors[ index + 2 ] = color.b;

                colors[ index + 3 ] = color.r;
                colors[ index + 4 ] = color.g;
                colors[ index + 5 ] = color.b;

                colors[ index + 6 ] = color.r;
                colors[ index + 7 ] = color.g;
                colors[ index + 8 ] = color.b;

                index += 9;

                }
            }
            bufferGeometry.attributes.position.needsUpdate = true;
            bufferGeometry.attributes.normal.needsUpdate = true;
            bufferGeometry.attributes.color.needsUpdate = true;
            bufferGeometry.computeBoundingSphere();

        };
        initViewSwitch();
        function initViewSwitch() {
            $('#view_switch_flat').click(function(event) {
                viewMode = '2d';

                controls.enabled = false;

                tweenSwitch = new TWEEN.Tween(animationProps)
                .to({interpolatePos: 0.0}, Config.viewSwitchDuration)
                .onUpdate(function() {
                    geometryNeedsUpdate = true;
                })
                .onComplete(function() {
                    controls = controlsPinchZoom;
                    controls.enabled = true;
                })
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

                tweenCameraPosition = new TWEEN.Tween(camera.position)
                .to({ x: 0, y: 0, z: Config.cameraDistance }, Config.viewSwitchDuration)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

                tweenCameraUp = new TWEEN.Tween(camera.up)
                .to({ x: 0, y: 1, z: 0 }, Config.viewSwitchDuration)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

            });

            $('#view_switch_spherical').click(function(event) {
                viewMode = '3d';

                controls.enabled = false;

                tweenSwitch = new TWEEN.Tween(animationProps)
                .to({interpolatePos: 1.0}, Config.viewSwitchDuration)
                .onUpdate(function() {
                    geometryNeedsUpdate = true;
                })
                .onComplete(function() {
                    controls = controlsTrackball;
                    controls.enabled = true;
                })
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

                tweenCameraPosition = new TWEEN.Tween(camera.position)
                .to({ x: 0, y: 0, z: Config.cameraDistance }, Config.viewSwitchDuration)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
            });
            };
        



    </script>
</body>

</html>