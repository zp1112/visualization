<!doctype html>  
<html>  
    <head>  
        <meta charset="utf-8"/>  
        <title>Grid</title>  
        <style>body{background:#eeeeee;margin:0;padding:0;}</style>  
        <script src="https://d3js.org/d3.v4.min.js"></script>
        <script src="https://threejs.org/build/three.js"></script>  
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.0/TweenMax.min.js"></script>
        <script src="//d3js.org/queue.v1.min.js"></script>
        <script src="https://www.wjceo.com/lib/js/libs/stats.min.js"></script>
        

        <style>
            #tooltip {
                position: absolute;
                background: #fff;
                padding: 10px;
                border-radius: 10px;
                display: none;
            }
            #bars, #sphere {
                position: absolute;
                background: #fff;
                padding: 10px;
                border-radius: 10px;
                left: 100px;
                top: 100px;
            }
            #sphere {
                top: 150px;
            }
        </style>
        
    </head>  
    <body>  
        <div id="tooltip"></div>
        <div id="bars">bars</div>
        <div id="sphere">sphere</div>

        <script>  
        const width = window.innerWidth;  
        const height = window.innerHeight;

        const scaleHeight = d3.scaleLinear();
        var cubes = new THREE.Group();
        cubes.name = 'cubes';
        var textGroup = new THREE.Group();
        var lineGroup = new THREE.Group();
        var camera;
        var stats;
        var curType = '';
        const minLat = 30;
        const maxLat = 47
        const minLon = 76;
        const maxLon = 133;
        const density = 2;
        const latCount = 50;
        const lonCount = 100;
        const cubeZ = 400 / latCount;
        const cubeX = 1000 / lonCount;
        const textLoader = new THREE.FontLoader();
        var cubeGeometry;
          
        const scene = new THREE.Scene();      //创建场景  
        scene.background = new THREE.Color( 0x000000 );
        //初始化性能插件
        function initStats() {
            stats = new Stats();
            document.body.appendChild(stats.dom);
        }
        initStats();

        function initOrthCamera(){
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 10000);
            // camera = new THREE.OrthographicCamera(window.innerWidth/-1.5,window.innerWidth/1.5,
            // window.innerHeight/1.5,window.innerHeight/-1.5,100,10000);
            camera.position.set(1000,1000, 1000);//设置相机坐标
            camera.lookAt({x: 0, y: 0, z: 0});//让相机指向场景中心
        }
        initOrthCamera();

        function initLight() {
            scene.add(new THREE.AmbientLight(0x444444));
            light = new THREE.DirectionalLight(0xffffff);
            light.position.set(15,50,10);
            //告诉平行光需要开启阴影投射

            light.castShadow = true;
            scene.add(light);
        }
        initLight();

        function gradientColor(startColor,endColor,step){
            startRGB = this.colorRgb(startColor);//转换为rgb数组模式
            startR = startRGB[0];
            startG = startRGB[1];
            startB = startRGB[2];
            endRGB = this.colorRgb(endColor);
            endR = endRGB[0];
            endG = endRGB[1];
            endB = endRGB[2];
            sR = (endR-startR)/step;//总差值
            sG = (endG-startG)/step;
            sB = (endB-startB)/step;
            var colorArr = [];
            for(var i=0;i<step;i++){
            //计算每一步的hex值 
            var hex = this.colorHex('rgb('+parseInt((sR*i+startR))+','+parseInt((sG*i+startG))+','+parseInt((sB*i+startB))+')');
            colorArr.push(hex);
            }
            return colorArr;
        }
        // 将hex表示方式转换为rgb表示方式(这里返回rgb数组模式)
        gradientColor.prototype.colorRgb = function(sColor){
            var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
            var sColor = sColor.toLowerCase();
            if(sColor && reg.test(sColor)){
            if(sColor.length === 4){
                var sColorNew = "#";
                for(var i=1; i<4; i+=1){
                sColorNew += sColor.slice(i,i+1).concat(sColor.slice(i,i+1));
                }
                sColor = sColorNew;
            }
            //处理六位的颜色值
            var sColorChange = [];
            for(var i=1; i<7; i+=2){
                sColorChange.push(parseInt("0x"+sColor.slice(i,i+2)));
            }
            return sColorChange;
            }else{
            return sColor;
            }
        };
        // 将rgb表示方式转换为hex表示方式
        gradientColor.prototype.colorHex = function(rgb){
            var _this = rgb;
            var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
            if(/^(rgb|RGB)/.test(_this)){
            var aColor = _this.replace(/(?:(|)|rgb|RGB)*/g,"").split(",");
            var strHex = "#";
            for(var i=0; i<aColor.length; i++){
                var hex = Number(aColor[i]).toString(16);
                hex = hex<10 ? 0+''+hex :hex;// 保证每个rgb的值为2位
                if(hex === "0"){
                hex += hex;
                }
                strHex += hex;
            }
            if(strHex.length !== 7){
                strHex = _this;
            }
            return strHex;
            }else if(reg.test(_this)){
            var aNum = _this.replace(/#/,"").split("");
            if(aNum.length === 6){
                return _this;
            }else if(aNum.length === 3){
                var numHex = "#";
                for(var i=0; i<aNum.length; i+=1){
                numHex += (aNum[i]+aNum[i]);
                }
                return numHex;
            }
            }else{
            return _this;
            }
        }

        textLoader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json", function(font) {
            const fontOptions = {
                    size: 18,
                    height: 0,
                    font, // “引用js字体必须换成英文”
                    bevelThickness: 1,
                    bevelSize: 1,
                    bevelSegments: 1,
                    curveSegments: 50,
                    steps: 1
                };
            function createText() {
                drawBarGrids();
                for(let i=0;i<=5;i++){
                        // 使用TextBufferGeometry比TextGeometry快
                        const textLeftTop = new THREE.TextBufferGeometry(scaleLinearLon.invert(i * 200).toFixed(2), fontOptions);
                        const textMeshLeftTop = new THREE.Mesh(textLeftTop, new THREE.MeshBasicMaterial());
                        
                        textMeshLeftTop.position.x = i * 200;
                        textMeshLeftTop.position.y = 400;
                        textMeshLeftTop.position.z = -30;
                        textMeshLeftTop.rotation.z = 45;
                        textMeshLeftTop.rotation.x = -45;
                        textGroup.add(textMeshLeftTop);
                }
                
                for(let i=0;i<=5;i++){
                        // 使用TextBufferGeometry比TextGeometry快
                        const textLeftTop = new THREE.TextBufferGeometry(scaleLinearLon.invert(i * 200).toFixed(2), fontOptions);
                        const textMeshLeftTop = new THREE.Mesh(textLeftTop, new THREE.MeshBasicMaterial());
                        
                        textMeshLeftTop.position.x = i * 200;
                        textMeshLeftTop.position.y = 0;
                        textMeshLeftTop.position.z = 800;
                        textMeshLeftTop.rotation.z = 45;
                        textMeshLeftTop.rotation.x = -45;
                        textGroup.add(textMeshLeftTop);
                }

                for(let i=0;i<=5;i++){
                        // 使用TextBufferGeometry比TextGeometry快
                        const textLeftTop = new THREE.TextBufferGeometry(scaleLinearLat.invert(i * 120).toFixed(2), fontOptions);
                        const textMeshLeftTop = new THREE.Mesh(textLeftTop, new THREE.MeshBasicMaterial());
                        
                        textMeshLeftTop.position.x = -100;
                        textMeshLeftTop.position.y = 400;
                        textMeshLeftTop.position.z = i * 120;
                        textMeshLeftTop.rotation.y = 45;
                        textMeshLeftTop.rotation.x = -45;
                        textGroup.add(textMeshLeftTop);
                }
                
                scene.add(textGroup);
            }
            function createZText(positions, n = 5) {
                    for(let i=0;i<n;i++){
                        // 使用TextBufferGeometry比TextGeometry快
                        const text = new THREE.TextBufferGeometry(positions.text ? JSON.stringify(positions.text(i)) : JSON.stringify(i * positions.n), fontOptions);
                        const textMesh = new THREE.Mesh(text, new THREE.MeshBasicMaterial());
                        
                        textMesh.position.x = typeof positions.x === 'function' ? positions.x(i) : positions.x;
                        textMesh.position.y = typeof positions.y === 'function' ? positions.y(i) : positions.y;
                        textMesh.position.z = typeof positions.z === 'function' ? positions.z(i) : positions.z;
                        textGroup.add(textMesh);
                    }
                }
            queue().defer(d3.csv, "./Bank-of-China-ATMs.csv").await(ready);
            const scaleLinearLat = d3.scaleLinear().domain([maxLat, minLat]).range([0, 600]);
            const scaleLinearLon = d3.scaleLinear().domain([minLon, maxLon]).range([0, 1000]);

            function ready(error, data) {
                for (const item of data) {
                    const posX = parseInt(scaleLinearLon(item.longitude) / cubeX);
                    const posZ = parseInt(scaleLinearLat(item.latitude) / cubeZ);
                    const centerPos = {
                        x: posX ? (posX - 1) * cubeX + cubeX / 2 : cubeX / 2,
                        z: posZ ? (posZ - 1) * cubeZ + cubeZ / 2 : cubeZ / 2
                    }
                    item.centerPos = centerPos;
                }

                const res = [];
                let temp = {};
                data.forEach(row => {
                    const fixed = JSON.stringify(row.centerPos);
                    if (temp[fixed]) {
                        temp[fixed].push(row);
                    } else {
                        temp[fixed] = [row];
                    }
                })
                Object.values(temp).map(row => res.push(row));
                let maxLen = Math.max(...(Object.values(temp).map(row => row.length)));
                // cubeY = 400 / maxLen > density ? density : 400 / maxLen;
                cubeY = 400 / maxLen;
                console.log(cubeX, cubeZ, cubeY)
                cubeGeometry = new THREE.BoxGeometry(cubeX, cubeY, cubeZ);
                scaleName = d3.scaleOrdinal().domain(data.map(val => val.name)).range(d3.range(0, 400, 20));
                cubesColorScale = d3.scaleLinear().domain([0, maxLen]).range([d3.rgb("#007AFF"), d3.rgb('#ff4300')]);

                const resLen = res.length;
                
                scaleHeight.domain([0, 400]).range([0, maxLen * cubeY]);

                const barsButton = document.getElementById('bars');
                barsButton.addEventListener('click', () => transGroup('spheres', 'cubes', data, res), false);
                const spheresButton = document.getElementById('sphere');
                spheresButton.addEventListener('click', () => transGroup('cubes', 'spheres', data, res), false);

                function createBar(item, index) {
                    var cubeGeometry = new THREE.BoxGeometry(5, 5, 5);
                    const group = new THREE.Group();
                    const material = new THREE.MeshLambertMaterial({
                        color: cubesColorScale(index), 
                        polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1,
                        shading: THREE.FlatShading,
                        transparent: false,
                        opacity: 1.0
                    });
                    const bar = new THREE.Mesh(cubeGeometry, material);
                    var helper = new THREE.BoxHelper( bar );
                    helper.material.color.set( 0xe0dede );
                    helper.material.linewidth = 3; // may no longer be supported on some platforms
                    group.add(bar);
                    group.add(helper);
                    group.position.z = item.position.z;
                    group.position.x = item.position.x;
                    group.position.y = item.position.y;
                    return group;
                }

                function transGroup(from, to, data, res) {
                    if (curType === to) {
                        return;
                    }
                    const item = window.cubes.children;
                    if (!item.length) {
                            renderBars(res);
                            return;
                    } else {
                        if (from === 'cubes') {
                            for(let i = 0, len = item.length; i < len; i ++) {
                                const { name, longitude, latitude } = data[i];
                                new TweenMax.to(item[i].position, 1, {
                                    y: scaleName(name) + cubeY,
                                    z: scaleLinearLat(latitude),
                                    x: scaleLinearLon(longitude)
                                });
                            }
                            scene.remove(lineGroup);
                            scene.remove(textGroup);
                            textGroup = new THREE.Group();
                            lineGroup = new THREE.Group();
                            createSphereText();
                            curType = 'spheres';
                        } else {
                            for(let i = 0, len = item.length; i < len; i ++) {
                                new TweenMax.to(item[i].position, 1, {
                                    y: scaleHeight.invert(item[i].j * cubeY) + scaleHeight.invert(cubeY),
                                    z: res[item[i].i][item[i].j].centerPos.z,
                                    x: res[item[i].i][item[i].j].centerPos.x
                                });
                            }
                            scene.remove(lineGroup);
                            scene.remove(textGroup);
                            textGroup = new THREE.Group();
                            lineGroup = new THREE.Group();
                            createBarsText();
                            curType = 'cubes';
                        }
                    }
                }
                transGroup('cubes', 'spheres', data, res);
                function renderBar(item, i, j) {
                            var group = new THREE.Group();
                            const material = new THREE.MeshLambertMaterial({
                                color: cubesColorScale(j),
                                transparent: true
                            });
                            cube = new THREE.Mesh(cubeGeometry, material);
                            group.customType = 'cube';
                            group.customName = item.name;
                            group.position.z = item.centerPos.z;
                            group.position.x = item.centerPos.x;
                            group.position.y = j * cubeY + cubeY;

                            var helper = new THREE.BoxHelper( cube );
                            helper.material.color.set( 0xe0dede );
                            helper.material.linewidth = 1; // may no longer be supported on some platforms
                            
                            group.add(cube);
                            group.add(helper);
                            group.i = i;
                            group.j = j;
                            item.centerPos.y = group.position.y;
                            cubes.add(group);
                }
                function renderBars(res) {
                    // 1688
                    for (let i = 0; i < resLen; i ++) {
                        for (let j = 0; j < res[i].length; j ++) {
                            renderBar(res[i][j], i, j);
                        }
                    }
                    scene.add(cubes);
                    curType = 'cubes';
                    createBarsText();
                }
                function createBarsText() {
                    createText();
                    // 使用TextBufferGeometry比TextGeometry快
                    const text = new THREE.TextBufferGeometry('Count', fontOptions);
                    const textMesh = new THREE.Mesh(text, new THREE.MeshBasicMaterial());
                    
                    textMesh.position.x = -100;
                    textMesh.position.y = 150;
                    textMesh.position.z = 600;
                    textGroup.add(textMesh);
                    // createZText({
                    //     text: i => i * 80,
                    //     n: 80,
                    //     x: -100,
                    //     y: function(i) {
                    //         return i * 80
                    //     },
                    //     z: 600
                    // });
                }
                function createSphereText() {
                    createText();
                    // 使用TextBufferGeometry比TextGeometry快
                    const text = new THREE.TextBufferGeometry('Name', fontOptions);
                    const textMesh = new THREE.Mesh(text, new THREE.MeshBasicMaterial());
                    
                    textMesh.position.x = -100;
                    textMesh.position.y = 150;
                    textMesh.position.z = 600;
                    textGroup.add(textMesh);
                }
            }
        })
        
        const texture = new THREE.ImageUtils.loadTexture( "./china.jpg" );
        let geometry = new THREE.PlaneGeometry(1000,600);
        let material = new THREE.MeshBasicMaterial( {
            map: texture
        });
        let rect = new THREE.Mesh(geometry,material);
        geometry.applyMatrix(new THREE.Matrix4().makeTranslation(500,-300, 0));
        rect.rotation.x = -Math.PI / 2;
        scene.add(rect);
        texture.needsUpdate	= true;
        console.warn = function(){};

        function drawBarGrids() {
            const geometryLeft = new THREE.Geometry();    //创建geometry  
            geometryLeft.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryLeft.vertices.push(new THREE.Vector3(20*50, 0, 0));  

            const geometryLeft1 = new THREE.Geometry();    //创建geometry  
            geometryLeft1.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryLeft1.vertices.push(new THREE.Vector3(20*30, 0, 0)); 
            
            // 底部面 600 * 1000
            for(let i=0;i<=5;i++){
                const line1 = new THREE.Line(geometryLeft, new THREE.LineBasicMaterial({color:0xff0000})); 
                line1.position.z = i*120; 
                lineGroup.add(line1);  
                
                const line11 = new THREE.Line(geometryLeft1, new THREE.LineBasicMaterial({color:0xff0000}));  
                line11.position.x = i*200;  
                line11.rotation.y = -Math.PI/2; 
                lineGroup.add(line11);  
            }

            const geometryBack = new THREE.Geometry();    //创建geometry  
            geometryBack.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryBack.vertices.push(new THREE.Vector3(0, 0, 20*30));  
            const geometryBack1 = new THREE.Geometry();    //创建geometry  
            geometryBack1.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryBack1.vertices.push(new THREE.Vector3(0, 0, 20*20)); 

            // 左边面 400 * 600
            for(let i=0;i<=5;i++){
                const line2 = new THREE.Line(geometryBack, new THREE.LineBasicMaterial({color:0x00ff00})); 
                line2.position.y = i*80; 
                lineGroup.add(line2);  
                
                const line22 = new THREE.Line(geometryBack1, new THREE.LineBasicMaterial({color:0x00ff00}));  
                line22.position.z = i*120;  
                line22.rotation.x = -Math.PI/2; 
                lineGroup.add(line22);  
            }

            const geometryBottom = new THREE.Geometry();    //创建geometry  
            geometryBottom.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryBottom.vertices.push(new THREE.Vector3(20*50, 0, 0)); 
            const geometryBottom1 = new THREE.Geometry();    //创建geometry  
            geometryBottom1.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryBottom1.vertices.push(new THREE.Vector3(20*20, 0, 0)); 
            // 后边面 400 * 1000
            for(let i=0;i<=5;i++){
                const line3 = new THREE.Line(geometryBottom, new THREE.LineBasicMaterial({color:0x0000ff})); 
                line3.position.y = i*80; 
                lineGroup.add(line3);  
                
                const line33 = new THREE.Line(geometryBottom1, new THREE.LineBasicMaterial({color:0x0000ff}));  
                line33.position.x = i*200;  
                line33.rotation.z = Math.PI/2; 
                lineGroup.add(line33);  
            }
            scene.add(lineGroup);

        }

        // mousemove事件
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltipPosition = {};
        let intersects = [];
        let INTERSECTED;
        const tooltip = document.getElementById('tooltip');
        document.addEventListener('mousemove', onmouseOver, false);

        function onmouseOver(event) {
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            tooltipPosition.x = event.clientX + 'px';
            tooltipPosition.y = event.clientY + 'px';
            getIntersectObjects();
        }
        function getIntersectObjects() {
            raycaster.setFromCamera(mouse, camera);

            intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length) {
                if (intersects[0].object.customType === 'cube' && INTERSECTED !== intersects[0].object) {
                    if (INTERSECTED) INTERSECTED.material.color.set( INTERSECTED.currentColor );
                    INTERSECTED = intersects[0].object;
                    INTERSECTED.currentColor = JSON.parse(JSON.stringify(INTERSECTED.material.color));
                    INTERSECTED.material.color.set( 0xff0000 );
                    tooltip.innerHTML = INTERSECTED.customName;
                    tooltip.style.left = tooltipPosition ? tooltipPosition.x : '';
                    tooltip.style.top = tooltipPosition ? tooltipPosition.y : '';
                    tooltip.style.display = 'block';
                }
            } else {
                if (INTERSECTED) INTERSECTED.material.color.set( INTERSECTED.currentColor );
            }
        }


        const renderer = new THREE.WebGLRenderer({antialias : true});     //创建渲染器（并设置抗锯齿属性）  
        renderer.setSize(width, height);    //设置渲染器的大小
        document.body.appendChild(renderer.domElement);     //添加渲染器的DOM元素到body中  
        const controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.screenSpacePanning = true;
        window.addEventListener('resize', function(){
            renderer.setSize(window.innerWidth, window.innerHeight);
        })
        
        function animate(time) {
            // 设置文字始终面向相机
            if (textGroup.length) {
                for (let i = 0; i < textGroup.length; i++) {
                    textGroup[i].lookAt(camera.position);
                }
            }
            stats.update();

            requestAnimationFrame( animate );
            renderer.render(scene, camera);

        }
        animate();  
        </script>  
    </body>  
</html>  