<!doctype html>  
<html>  
    <head>  
        <meta charset="utf-8"/>  
        <title>Grid</title>  
        <style>body{background:#eeeeee;margin:0;padding:0;}</style>  
        <script src="https://d3js.org/d3.v4.min.js"></script>
        <script src="https://threejs.org/build/three.js"></script>  
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.0/TweenMax.min.js"></script>
        <script src="//d3js.org/queue.v1.min.js"></script>
        <script src="https://www.wjceo.com/lib/js/libs/stats.min.js"></script>
        

        <style>
            #tooltip {
                position: absolute;
                background: #fff;
                padding: 10px;
                border-radius: 10px;
                display: none;
            }
            #bars, #sphere {
                position: absolute;
                background: #fff;
                padding: 10px;
                border-radius: 10px;
                left: 100px;
                top: 100px;
            }
            #sphere {
                top: 150px;
            }
        </style>
        
    </head>  
    <body>  
        <div id="tooltip"></div>
        <div id="bars">bars</div>
        <div id="sphere">sphere</div>

        <script>  
        const width = window.innerWidth;  
        const height = window.innerHeight;

        // var cubes = new THREE.Group();
        // cubes.name = 'cubes';
        var cubes = [];
        var textGroup = new THREE.Group();
        var lineGroup = new THREE.Group();
        var camera;
        var stats;
        var curType = '';

        const minLat = 30;
        const maxLat = 47
        const minLon = 76;
        const maxLon = 133;

        const xAxis = 1000;
        const zAxis = 600;
        const yAxis = 400;

        var cubeX;
        var cubeZ;
        var cubeY;
        var maxCount;

        const textLoader = new THREE.FontLoader();

        var cubeGeometry;
        var zTextMesh; // z轴文字
          
        const scene = new THREE.Scene();      //创建场景  
        scene.background = new THREE.Color( 0x000000 );
        //初始化性能插件
        function initStats() {
            stats = new Stats();
            document.body.appendChild(stats.dom);
        }
        initStats();

        function initOrthCamera(){
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 10000);
            // camera = new THREE.OrthographicCamera(window.innerWidth/-1.5,window.innerWidth/1.5,
            // window.innerHeight/1.5,window.innerHeight/-1.5,100,10000);
            camera.position.set(1000,1000, 1000);//设置相机坐标
            camera.lookAt({x: 0, y: 0, z: 0});//让相机指向场景中心
        }
        initOrthCamera();

        function initLight() {
            scene.add(new THREE.AmbientLight(0x444444));
            light = new THREE.DirectionalLight(0xffffff);
            light.position.set(15,50,10);
            //告诉平行光需要开启阴影投射

            light.castShadow = true;
            scene.add(light);
        }
        initLight();
        textLoader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json", function(font) {
            const fontOptions = {
                    size: 18,
                    height: 0,
                    font, // “引用js字体必须换成英文”
                    bevelThickness: 1,
                    bevelSize: 1,
                    bevelSegments: 1,
                    curveSegments: 50,
                    steps: 1
                };
            function createText() {
                drawBarGrids();
                const n = 5;
                for(let i=0;i<=n;i++){
                        // 使用TextBufferGeometry比TextGeometry快
                        const textLeftTop = new THREE.TextBufferGeometry(scaleLinearLon.invert(i * 200).toFixed(2), fontOptions);
                        const textMeshLeftTop = new THREE.Mesh(textLeftTop, new THREE.MeshBasicMaterial());
                        
                        textMeshLeftTop.position.x = i * xAxis / n;
                        textMeshLeftTop.position.y = yAxis;
                        textMeshLeftTop.position.z = -30;
                        textMeshLeftTop.rotation.z = 45;
                        textMeshLeftTop.rotation.x = -45;
                        textGroup.add(textMeshLeftTop);
                }
                
                for(let i=0;i<=n;i++){
                        // 使用TextBufferGeometry比TextGeometry快
                        const textLeftTop = new THREE.TextBufferGeometry(scaleLinearLon.invert(i * 200).toFixed(2), fontOptions);
                        const textMeshLeftTop = new THREE.Mesh(textLeftTop, new THREE.MeshBasicMaterial());
                        
                        textMeshLeftTop.position.x = i * xAxis / n;
                        textMeshLeftTop.position.y = 0;
                        textMeshLeftTop.position.z = zAxis + 100;
                        textMeshLeftTop.rotation.z = 45;
                        textMeshLeftTop.rotation.x = -45;
                        textGroup.add(textMeshLeftTop);
                }

                for(let i=0;i<=n;i++){
                        // 使用TextBufferGeometry比TextGeometry快
                        const textLeftTop = new THREE.TextBufferGeometry(scaleLinearLat.invert(i * 120).toFixed(2), fontOptions);
                        const textMeshLeftTop = new THREE.Mesh(textLeftTop, new THREE.MeshBasicMaterial());
                        
                        textMeshLeftTop.position.x = -100;
                        textMeshLeftTop.position.y = yAxis;
                        textMeshLeftTop.position.z = i * zAxis / n;
                        textMeshLeftTop.rotation.y = 45;
                        textMeshLeftTop.rotation.x = -45;
                        textGroup.add(textMeshLeftTop);
                }
                scene.add(textGroup);
            }
            queue().defer(d3.csv, "./Bank-of-China-ATMs.csv").await(ready);
            const scaleLinearLat = d3.scaleLinear().domain([maxLat, minLat]).range([0, zAxis]);
            const scaleLinearLon = d3.scaleLinear().domain([minLon, maxLon]).range([0, xAxis]);

            function ready(error, data) {
                const res = [];
                let temp = {};
                function formatData1() {
                    const density = 10;
                    cubeX = density;
                    cubeZ = density;
                    for (const item of data) {
                        const posX = parseInt(scaleLinearLon(item.longitude) / density);
                        const posZ = parseInt(scaleLinearLat(item.latitude) / density);
                        let x = (posX - 1) * density + density * 3 / 2;
                        let z = (posZ - 1) * density + density * 3 / 2;
                        if (x > xAxis - density / 2) {
                            x = x - density;
                        }
                        if (z > zAxis - density / 2) {
                            z = z - density;
                        }
                        const centerPos = { x, z };
                        item.centerPos = centerPos;
                    }
                    data.forEach(row => {
                        const fixed = JSON.stringify(row.centerPos);
                        if (temp[fixed]) {
                            temp[fixed].push(row);
                        } else {
                            temp[fixed] = [row];
                        }
                    })
                    Object.values(temp).map(row => res.push(row));
                    maxCount = Math.max(...(Object.values(temp).map(row => row.length)));
                    cubeY = 400 / maxCount;
                    if (cubeY < density) {
                        cubeX = cubeZ = cubeY;
                    }
                }
                
                function formatData2() {
                    const latCount = 60;
                    const lonCount = 100;
                    cubeX = xAxis / lonCount;
                    cubeZ = zAxis / latCount;
                    for (const item of data) {
                        const posX = parseInt(scaleLinearLon(item.longitude) / cubeX);
                        const posZ = parseInt(scaleLinearLat(item.latitude) / cubeZ);
                        const centerPos = {
                            x: posX ? (posX - 1) * cubeX + cubeX / 2 : cubeX / 2,
                            z: posZ ? (posZ - 1) * cubeZ + cubeZ / 2 : cubeZ / 2
                        }
                        item.centerPos = centerPos;
                    }
                    data.forEach(row => {
                        const fixed = JSON.stringify(row.centerPos);
                        if (temp[fixed]) {
                            temp[fixed].push(row);
                        } else {
                            temp[fixed] = [row];
                        }
                    })
                    Object.values(temp).map(row => res.push(row));
                    maxCount = Math.max(...(Object.values(temp).map(row => row.length)));
                    cubeY = 400 / maxCount;
                }
                // formatData2();
                formatData1();
                console.log(cubeX, cubeZ, cubeY)
                cubeGeometry = new THREE.BoxGeometry(cubeX, cubeY, cubeZ);
                scaleName = d3.scaleOrdinal().domain(data.map(val => val.name)).range(d3.range(0, 400, 20));
                cubesColorScale = d3.scaleLinear().domain([0, maxCount]).range([d3.rgb("#007AFF"), d3.rgb('#ff4300')]);

                const resLen = res.length;

                const barsButton = document.getElementById('bars');
                barsButton.addEventListener('click', () => transGroup('spheres', 'cubes', data, res), false);
                const spheresButton = document.getElementById('sphere');
                spheresButton.addEventListener('click', () => transGroup('cubes', 'spheres', data, res), false);

                function transGroup(from, to, data, res) {
                    if (curType === to) {
                        return;
                    }
                    const item = window.cubes;
                    let name;
                    if (!item.length) {
                            renderBars(res);
                            return;
                    } else {
                        if (from === 'cubes') {
                            name = 'Name';
                            for(let i = 0, len = item.length; i < len; i ++) {
                                const { name, longitude, latitude } = data[i];
                                new TweenMax.to(item[i][0].position, 1, {
                                    y: scaleName(name) + cubeY,
                                    z: scaleLinearLat(latitude),
                                    x: scaleLinearLon(longitude),
                                    onUpdate: () => {  
                                        item[i][1].position.x = scaleLinearLon(longitude);
                                        item[i][1].position.y = scaleName(name) + cubeY;
                                        item[i][1].position.z = scaleLinearLat(latitude);
                                        item[i][1].update();
                                    }
                                });
                            }
                        } else {
                            name = 'Count';
                            for(let i = 0, len = item.length; i < len; i ++) {
                                new TweenMax.to(item[i][0].position, 1, {
                                    y: res[item[i].i][item[i].j].centerPos.y,
                                    z: res[item[i].i][item[i].j].centerPos.z,
                                    x: res[item[i].i][item[i].j].centerPos.x,
                                    onUpdate: () => {  
                                        item[i][1].position.y = res[item[i].i][item[i].j].centerPos.y,
                                        item[i][1].position.z = res[item[i].i][item[i].j].centerPos.z,
                                        item[i][1].position.x = res[item[i].i][item[i].j].centerPos.x
                                        item[i][1].update();
                                    }
                                });
                            }
                        }
                        scene.remove(zTextMesh);
                        createZText(name);
                        curType = to;
                    }
                }
                transGroup('cubes', 'spheres', data, res);
                function renderBar(item, i, j) {
                            const material = new THREE.MeshLambertMaterial({
                                color: cubesColorScale(j),
                                transparent: true
                            });
                            cube = new THREE.Mesh(cubeGeometry, material);
                            cube.customType = 'cube';
                            cube.customName = item.name;
                            cube.position.z = item.centerPos.z;
                            cube.position.x = item.centerPos.x;
                            cube.position.y = j * cubeY + cubeY;
                            item.centerPos.y = cube.position.y;

                            var helper = new THREE.BoxHelper( cube );
                            helper.material.color.set( 0xe0dede );
                            helper.material.linewidth = 1; // may no longer be supported on some platforms
                            helper.position.z = item.centerPos.z;
                            helper.position.x = item.centerPos.x;
                            helper.position.y = j * cubeY + cubeY;

                            const subArr = [cube, helper];

                            subArr.i = i;
                            subArr.j = j;
                            cubes.push(subArr);
                            scene.add(cube);
                            scene.add(helper);
                }
                function renderBars(res) {
                    for (let i = 0; i < resLen; i ++) {
                        for (let j = 0; j < res[i].length; j ++) {
                            renderBar(res[i][j], i, j);
                        }
                    }
                    curType = 'cubes';
                    createText();
                    createZText('Count');
                }
                function createZText (name) {
                    // 使用TextBufferGeometry比TextGeometry快
                    const text = new THREE.TextBufferGeometry(name, fontOptions);
                    zTextMesh = new THREE.Mesh(text, new THREE.MeshBasicMaterial());
                    
                    zTextMesh.position.x = -100;
                    zTextMesh.position.y = 150;
                    zTextMesh.position.z = 600;
                    scene.add(zTextMesh);
                }
            }
        })
        
        const texture = new THREE.ImageUtils.loadTexture( "./china.jpg" );
        let geometry = new THREE.PlaneGeometry(xAxis,zAxis);
        let material = new THREE.MeshBasicMaterial( {
            map: texture,
            side:THREE.DoubleSide
        });
        let rect = new THREE.Mesh(geometry,material);
        geometry.applyMatrix(new THREE.Matrix4().makeTranslation(xAxis / 2, zAxis / 2, 0));
        rect.rotation.x =  Math.PI / 2;
        scene.add(rect);
        texture.needsUpdate	= true;
        console.warn = function(){};

        function drawBarGrids() {
            const geometryLeft = new THREE.Geometry();    //创建geometry  
            geometryLeft.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryLeft.vertices.push(new THREE.Vector3(xAxis, 0, 0));  

            const geometryLeft1 = new THREE.Geometry();    //创建geometry  
            geometryLeft1.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryLeft1.vertices.push(new THREE.Vector3(zAxis, 0, 0)); 
            const n = 5;
            
            // 底部面 600 * 1000
            for(let i=0;i<=n;i++){
                const line1 = new THREE.Line(geometryLeft, new THREE.LineBasicMaterial({color:0xff0000})); 
                line1.position.z = i*zAxis/n; 
                lineGroup.add(line1);  
                
                const line11 = new THREE.Line(geometryLeft1, new THREE.LineBasicMaterial({color:0xff0000}));  
                line11.position.x = i*xAxis/n;  
                line11.rotation.y = -Math.PI/2; 
                lineGroup.add(line11);  
            }

            const geometryBack = new THREE.Geometry();    //创建geometry  
            geometryBack.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryBack.vertices.push(new THREE.Vector3(0, 0, zAxis));  
            const geometryBack1 = new THREE.Geometry();    //创建geometry  
            geometryBack1.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryBack1.vertices.push(new THREE.Vector3(0, 0, yAxis)); 

            // 左边面 400 * 600
            for(let i=0;i<=n;i++){
                const line2 = new THREE.Line(geometryBack, new THREE.LineBasicMaterial({color:0x00ff00})); 
                line2.position.y = i*yAxis/n; 
                lineGroup.add(line2);  
                
                const line22 = new THREE.Line(geometryBack1, new THREE.LineBasicMaterial({color:0x00ff00}));  
                line22.position.z = i*zAxis/n;  
                line22.rotation.x = -Math.PI/2; 
                lineGroup.add(line22);  
            }

            const geometryBottom = new THREE.Geometry();    //创建geometry  
            geometryBottom.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryBottom.vertices.push(new THREE.Vector3(xAxis, 0, 0)); 
            const geometryBottom1 = new THREE.Geometry();    //创建geometry  
            geometryBottom1.vertices.push(new THREE.Vector3(0, 0 ,0));  //添加顶点  
            geometryBottom1.vertices.push(new THREE.Vector3(yAxis, 0, 0)); 
            // 后边面 400 * 1000
            for(let i=0;i<=n;i++){
                const line3 = new THREE.Line(geometryBottom, new THREE.LineBasicMaterial({color:0x0000ff})); 
                line3.position.y = i*yAxis/n; 
                lineGroup.add(line3);  
                
                const line33 = new THREE.Line(geometryBottom1, new THREE.LineBasicMaterial({color:0x0000ff}));  
                line33.position.x = i*xAxis/n;  
                line33.rotation.z = Math.PI/2; 
                lineGroup.add(line33);  
            }
            scene.add(lineGroup);
        }

        // mousemove事件
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltipPosition = {};
        let intersects = [];
        let INTERSECTED;
        const tooltip = document.getElementById('tooltip');
        document.addEventListener('mousemove', onmouseOver, false);

        function onmouseOver(event) {
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            tooltipPosition.x = event.clientX + 'px';
            tooltipPosition.y = event.clientY + 'px';
            getIntersectObjects();
        }
        function getIntersectObjects() {
            raycaster.setFromCamera(mouse, camera);

            intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length) {
                if (intersects[0].object.customType === 'cube' && INTERSECTED !== intersects[0].object) {
                    if (INTERSECTED) INTERSECTED.material.color.set( INTERSECTED.currentColor );
                    INTERSECTED = intersects[0].object;
                    INTERSECTED.currentColor = JSON.parse(JSON.stringify(INTERSECTED.material.color));
                    INTERSECTED.material.color.set( 0xff0000 );
                    tooltip.innerHTML = INTERSECTED.customName;
                    tooltip.style.left = tooltipPosition ? tooltipPosition.x : '';
                    tooltip.style.top = tooltipPosition ? tooltipPosition.y : '';
                    tooltip.style.display = 'block';
                }
            } else {
                if (INTERSECTED) INTERSECTED.material.color.set( INTERSECTED.currentColor );
                    tooltip.style.display = 'none';
            }
        }


        const renderer = new THREE.WebGLRenderer({antialias : true});     //创建渲染器（并设置抗锯齿属性）  
        renderer.setSize(width, height);    //设置渲染器的大小
        document.body.appendChild(renderer.domElement);     //添加渲染器的DOM元素到body中  
        const controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.screenSpacePanning = true;
        window.addEventListener('resize', function(){
            renderer.setSize(window.innerWidth, window.innerHeight);
        })
        
        function animate(time) {
            // 设置文字始终面向相机
            if (textGroup.length) {
                for (let i = 0; i < textGroup.length; i++) {
                    textGroup[i].lookAt(camera.position);
                }
            }
            stats.update();

            requestAnimationFrame( animate );
            renderer.render(scene, camera);

        }
        animate();  
        </script>  
    </body>  
</html>  