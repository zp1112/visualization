<html>

<head>
    <title>Three js Line</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/1.6.20/topojson.min.js"></script>
</head>

<body>
    <script>
        var radius = 100;
        function wireframe(multilinestring, radius, material) {
            const geometry = new THREE.Geometry();
            for (const P of multilinestring.coordinates) {
                for (let p0, p1 = vertex(P[0], radius), i = 1; i < P.length; ++i) {
                    geometry.vertices.push(p0 = p1, p1 = vertex(P[i], radius));
                }
            }
            return new THREE.LineSegments(geometry, material);
        }

        function vertex([longitude, latitude], radius) {
            const lambda = longitude * Math.PI / 180;
            const phi = latitude * Math.PI / 180;
            return new THREE.Vector3(
                radius * Math.cos(phi) * Math.cos(lambda),
                radius * Math.sin(phi),
                -radius * Math.cos(phi) * Math.sin(lambda)
            );
        }

        land = async () => {
            const response = await fetch("https://cdn.jsdelivr.net/npm/world-atlas@1/world/50m.json");
            const topology = await response.json();
            const mesh = topojson.mesh(topology, topology.objects.land);
            return wireframe(mesh, radius, new THREE.LineBasicMaterial({ color: 0xff0000 }));
        }


        graticule = () => {
            const mesh = graticule10();
            return wireframe(mesh, radius, new THREE.LineBasicMaterial({ color: 0xaaaaaa }));
        }


        function graticule10() { // See https://github.com/d3/d3-geo/issues/95
            return {
                type: "MultiLineString",
                coordinates: [].concat(
                    Array.from(
                        range(-180, 180, 10),
                        x => x % 90 ? meridian(x, -80, 80) : meridian(x, -90, 90)
                    ),
                    Array.from(
                        range(-80, 80 + 1e-6, 10),
                        y => parallel(y, -180, 180)
                    )
                )
            };
        }

        function meridian(x, y0, y1, dy = 2.5) {
            return Array.from(range(y0, y1 + 1e-6, dy), y => [x, y]);
        }

        function parallel(y, x0, x1, dx = 2.5) {
            return Array.from(range(x0, x1 + 1e-6, dx), x => [x, y]);
        }

        function* range(start, stop, step) {
            for (let i = 0, v = start; v < stop; v = start + (++i * step)) {
                yield v;
            }
        }
        init = async() => {

            const fov = 70;
            const aspect = window.innerWidth / window.innerHeight;
            const near = 1;
            const far = 1000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(80, 150, 150);//设置相机坐标
            camera.lookAt({ x: 0, y: 0, z: 0 });//让相机指向场景中心

            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: false });     //创建渲染器（并设置抗锯齿属性）
            renderer.setSize(window.innerWidth, window.innerHeight);    //设置渲染器的大小
            document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.screenSpacePanning = true;
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            scene.add(graticule());
            scene.add(await land());
            scene.add(new THREE.AmbientLight(0x444444));
            light = new THREE.DirectionalLight(0xffffff);
            light.position.set(15, 50, 10);
            //告诉平行光需要开启阴影投射

            light.castShadow = true;
            scene.add(light);
            render();
        function render() {
            requestAnimationFrame(render)
            renderer.render(scene, camera);
        }
        }
        init();

        



    </script>
</body>

</html>