<!doctype html>  
<html>  
    <head>  
        <meta charset="utf-8"/>  
        <title>Grid</title>  
        <style>body{background:#eeeeee;margin:0;padding:0;}</style>  
        <script src="https://d3js.org/d3.v4.min.js"></script>
        <script src="https://threejs.org/build/three.js"></script>  
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.0/TweenMax.min.js"></script>
        <script src="//d3js.org/queue.v1.min.js"></script>
        <script src="https://www.wjceo.com/lib/js/libs/stats.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
        <script src="./js/drawaxis.js"></script>
        

        <style>
            #tooltip {
                position: absolute;
                background: #fff;
                padding: 10px;
                border-radius: 10px;
                display: none;
            }
            #bars, #spheres, #cubes {
                position: absolute;
                background: #fff;
                padding: 10px;
                border-radius: 10px;
                left: 100px;
                top: 100px;
            }
            #spheres {
                top: 150px;
            }
            #bars {
                top: 200px;
            }
        </style>
        
    </head>  
    <body>  
        <div id="tooltip"></div>
        <div id="cubes">cubes</div>
        <div id="spheres">spheres</div>
        <div id="bars">bars</div>

        <script>  
        const width = window.innerWidth;  
        const height = window.innerHeight;

        var cubes = [];
        var camera;
        var stats;
        var curType = '';

        const cubeAxis = {
            xAxis: 1000,
            yAxis: 400,
            zAxis: 600,
            grid: 100
        }
        const sphereAxis = {
            xAxis: 1000,
            yAxis: 600,
            zAxis: 600,
            grid: 100
        }
        const barAxis = {
            bandWidth: 6,
            xAxis: 1000
        }

        var cubeX;
        var cubeZ;
        var cubeY;
        var maxCount;

        const textLoader = new THREE.FontLoader();

        var cubeGeometry;

        var scaleLinearLat;
        var scaleLinearLon;

        var fontOptions;

        const texture = new THREE.ImageUtils.loadTexture( "./china.jpg" );

        var res, res1;

        var sphereGridGroup = new THREE.Group();
        var barGridGroup = new THREE.Group();
        var cubeGridGroup = new THREE.Group();
          
        const scene = new THREE.Scene();      //创建场景  
        scene.background = new THREE.Color( 0x000000 );
        //初始化性能插件
        function initStats() {
            stats = new Stats();
            document.body.appendChild(stats.dom);
        }
        initStats();

        function initOrthCamera(){
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 10000);
            // camera = new THREE.OrthographicCamera(window.innerWidth/-1.5,window.innerWidth/1.5,
            // window.innerHeight/1.5,window.innerHeight/-1.5,100,10000);
            camera.position.set(500,1000, 1000);//设置相机坐标
            camera.lookAt({x: 0, y: 0, z: 0});//让相机指向场景中心
        }
        initOrthCamera();

        function initLight() {
            scene.add(new THREE.AmbientLight(0x444444));
            light = new THREE.DirectionalLight(0xffffff);
            light.position.set(15,50,10);
            //告诉平行光需要开启阴影投射

            light.castShadow = true;
            scene.add(light);
        }
        initLight();
        textLoader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json", function(font) {
            fontOptions = {
                size: 14,
                height: 0,
                font, // “引用js字体必须换成英文”
                bevelThickness: 1,
                bevelSize: 1,
                bevelSegments: 1,
                curveSegments: 50,
                steps: 1
            };
            queue().defer(d3.csv, "./bank.csv").await(ready);
        })

            function ready(error, data) {
                res = [];
                let temp = {};
                const maxLat = Math.max(...(data.map(row => row.latitude)));
                const minLat = Math.min(...(data.map(row => row.latitude)));
                const maxLon = Math.max(...(data.map(row => row.longitude)));
                const minLon = Math.min(...(data.map(row => row.longitude)));
                scaleLinearLat = d3.scaleLinear().domain([maxLat, minLat]).range([0, cubeAxis.zAxis]);
                scaleLinearLon = d3.scaleLinear().domain([minLon, maxLon]).range([0, cubeAxis.xAxis]);
                function formatData1() {
                    const { xAxis, yAxis, zAxis } = cubeAxis;
                    const density = 10;
                    cubeX = density;
                    cubeZ = density;
                    for (const item of data) {
                        const posX = parseInt(scaleLinearLon(item.longitude) / density);
                        const posZ = parseInt(scaleLinearLat(item.latitude) / density);
                        let x = (posX - 1) * density + density * 3 / 2;
                        let z = (posZ - 1) * density + density * 3 / 2;
                        if (x > xAxis - density / 2) {
                            x = x - density;
                        }
                        if (z > zAxis - density / 2) {
                            z = z - density;
                        }
                        const centerPos = { x, z };
                        item.centerPos = centerPos;
                    }
                    data.forEach(row => {
                        const fixed = JSON.stringify(row.centerPos);
                        if (temp[fixed]) {
                            temp[fixed].push(row);
                        } else {
                            temp[fixed] = [row];
                        }
                    })
                    Object.values(temp).map(row => res.push(row));
                    maxCount = Math.max(...(Object.values(temp).map(row => row.length)));
                    cubeY = 400 / maxCount;
                    if (cubeY < density) {
                        cubeX = cubeZ = cubeY;
                    }
                }
                
                function formatData2() {
                    const { xAxis, yAxis, zAxis } = cubeAxis;
                    const latCount = 60;
                    const lonCount = 100;
                    cubeX = xAxis / lonCount;
                    cubeZ = zAxis / latCount;
                    for (const item of data) {
                        const posX = parseInt(scaleLinearLon(item.longitude) / cubeX);
                        const posZ = parseInt(scaleLinearLat(item.latitude) / cubeZ);
                        const centerPos = {
                            x: posX ? (posX - 1) * cubeX + cubeX / 2 : cubeX / 2,
                            z: posZ ? (posZ - 1) * cubeZ + cubeZ / 2 : cubeZ / 2
                        }
                        item.centerPos = centerPos;
                    }
                    data.forEach(row => {
                        const fixed = JSON.stringify(row.centerPos);
                        if (temp[fixed]) {
                            temp[fixed].push(row);
                        } else {
                            temp[fixed] = [row];
                        }
                    })
                    Object.values(temp).map(row => res.push(row));
                    maxCount = Math.max(...(Object.values(temp).map(row => row.length)));
                    cubeY = 400 / maxCount;
                }
                // formatData2();
                formatData1();
                if (cubeY > cubeX) {
                    cubeY = cubeX
                }
                res1 = [];
                for (const item of data) {
                    const month = new Date(item.date).getMonth();
                    if (!res1[month]) {
                        res1[month] = 1;
                    } 
                    item.index = res1[month] - 1;
                    item.month = month;
                    res1[month] += 1;
                }

                barAxis.perCount = Math.ceil(barAxis.xAxis / 12 / cubeX);
                barAxis.xAxis = (barAxis.perCount * cubeX + barAxis.bandWidth) * 12;
                barAxis.yAxis = Math.max(...(Object.values(res1))) / 6 * cubeY;
                barAxis.ygrid = barAxis.perCount * cubeY;
                barAxis.grid = barAxis.perCount * cubeX + barAxis.bandWidth;
                barAxis.zAxis = cubeZ;

                console.log(999, barAxis)
                
                cubeGeometry = new THREE.BoxGeometry(cubeX, cubeY, cubeZ);
                scaleTime = d3.scaleTime().range([0, 600]).domain((d3.extent(data, function(d) { return new Date(d.date); })))
                cubesColorScale = d3.scaleLinear().domain([0, maxCount]).range([d3.rgb("#007AFF"), d3.rgb('#ff4300')]);

                const resLen = res.length;

                const cubesButton = document.getElementById('cubes');
                cubesButton.addEventListener('click', () => transGroup('cubes', data, res), false);
                const spheresButton = document.getElementById('spheres');
                spheresButton.addEventListener('click', () => transGroup('spheres', data, res), false);
                const barsButton = document.getElementById('bars');
                barsButton.addEventListener('click', () => transGroup('bars', data, res), false);

                initBarText(barAxis);
                initSphereText('Name', sphereAxis);
                initCubeText('Count', cubeAxis);

                function transGroup(to, data, res) {
                    if (curType === to) {
                        return;
                    } else {
                        removeText(cubeGridGroup);
                        removeText(barGridGroup);
                        removeText(sphereGridGroup);
                        const len = cubes.length;
                        let count = 0;
                        if (to === 'spheres') {
                            for(let i = 0; i < len; i ++) {
                                const { date, longitude, latitude } = data[i];
                                new TweenMax.to(cubes[i][0].position, 1, {
                                    y: scaleTime(new Date(date)) + cubeY,
                                    z: scaleLinearLat(latitude),
                                    x: scaleLinearLon(longitude),
                                    onUpdate: () => {  
                                        cubes[i][1].position.x = scaleLinearLon(longitude);
                                        cubes[i][1].position.y = scaleTime(new Date(date)) + cubeY;
                                        cubes[i][1].position.z = scaleLinearLat(latitude);
                                        cubes[i][1].update();
                                    },
                                    onComplete: () => {
                                        count += 1;
                                        if (count === len) {
                                            showText(sphereGridGroup);
                                        }
                                    }
                                });
                            }
                            
                        } else if(to === 'bars') {
                            const { perCount, bandWidth } = barAxis;
                            for(let i = 0; i < len; i ++) {
                                new TweenMax.to(cubes[i][0].position, 1, {
                                    y: Math.floor(cubes[i].index / perCount) * cubeY + cubeY / 2,
                                    z: cubeZ / 2,
                                    x: cubes[i].index % perCount * cubeX + cubeX / 2 + cubes[i].month * (cubeX * perCount + bandWidth) + bandWidth / 2,
                                    onUpdate: () => {  
                                        cubes[i][1].position.x = cubes[i].index % perCount * cubeX + cubes[i].month;
                                        cubes[i][1].position.y = cubes[i].index % perCount * cubeY + cubes[i].month;
                                        cubes[i][1].position.z = 0;
                                        cubes[i][1].update();
                                    },
                                    onComplete: () => {
                                        count += 1;
                                        if (count === len) {
                                            showText(barGridGroup);
                                        }
                                    }
                                });
                            }
                        } else {
                            for(let i = 0; i < len; i ++) {
                                new TweenMax.to(cubes[i][0].position, 1, {
                                    y: res[cubes[i].i][cubes[i].j].centerPos.y,
                                    z: res[cubes[i].i][cubes[i].j].centerPos.z,
                                    x: res[cubes[i].i][cubes[i].j].centerPos.x,
                                    onUpdate: () => {  
                                        cubes[i][1].position.y = res[cubes[i].i][cubes[i].j].centerPos.y,
                                        cubes[i][1].position.z = res[cubes[i].i][cubes[i].j].centerPos.z,
                                        cubes[i][1].position.x = res[cubes[i].i][cubes[i].j].centerPos.x
                                        cubes[i][1].update();
                                    },
                                    onComplete: () => {
                                        count += 1;
                                        if (count === len) {
                                            showText(cubeGridGroup);
                                        }
                                    }
                                });
                            }
                        }
                        curType = to;
                    }
                }
                
                function renderBar(item, i, j) {
                            const material = new THREE.MeshLambertMaterial({
                                color: '#57f972',
                                transparent: true
                            });
                            cube = new THREE.Mesh(cubeGeometry, material);
                            cube.customType = 'cube';
                            cube.customName = item.date;
                            cube.customLat = item.latitude;
                            cube.customLon = item.longitude;
                            cube.position.z = item.centerPos.z;
                            cube.position.x = item.centerPos.x;
                            cube.position.y = j * cubeY + cubeY / 2;
                            item.centerPos.y = cube.position.y;

                            var helper = new THREE.BoxHelper( cube );
                            helper.material.color.set( 0xe0dede );
                            helper.material.linewidth = 0.1; // may no longer be supported on some platforms
                            helper.position.z = item.centerPos.z;
                            helper.position.x = item.centerPos.x;
                            helper.position.y = j * cubeY + cubeY / 2;

                            const subArr = [cube, helper];

                            subArr.i = i;
                            subArr.j = j;
                            subArr.month = item.month;
                            subArr.index = item.index;
                            
                            cubes.push(subArr);
                            scene.add(cube);
                            scene.add(helper);
                }
                function renderBars() {
                    for (let i = 0; i < resLen; i ++) {
                        for (let j = 0; j < res[i].length; j ++) {
                            renderBar(res[i][j], i, j);
                        }
                    }
                    curType = 'cubes';
                    showText(cubeGridGroup);
                }
                renderBars();
            }


        // mousemove事件
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltipPosition = {};
        let intersects = [];
        let INTERSECTED;
        const tooltip = document.getElementById('tooltip');
        document.addEventListener('mousemove', onmouseOver, false);

        function onmouseOver(event) {
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            tooltipPosition.x = event.clientX + 'px';
            tooltipPosition.y = event.clientY + 'px';
            getIntersectObjects();
        }
        function getIntersectObjects() {
            raycaster.setFromCamera(mouse, camera);

            intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length) {
                if (intersects[0].object.customType === 'cube' && INTERSECTED !== intersects[0].object) {
                    if (INTERSECTED) INTERSECTED.material.color.set( INTERSECTED.currentColor );
                    INTERSECTED = intersects[0].object;
                    INTERSECTED.currentColor = JSON.parse(JSON.stringify(INTERSECTED.material.color));
                    INTERSECTED.material.color.set( 0xff0000 );
                    tooltip.innerHTML = INTERSECTED.customName + '-' + INTERSECTED.customLon + '-' + INTERSECTED.customLat;
                    tooltip.style.left = tooltipPosition ? tooltipPosition.x : '';
                    tooltip.style.top = tooltipPosition ? tooltipPosition.y : '';
                    tooltip.style.display = 'block';
                }
            } else {
                if (INTERSECTED) INTERSECTED.material.color.set( INTERSECTED.currentColor );
                    tooltip.style.display = 'none';
            }
        }

        const renderer = new THREE.WebGLRenderer({antialias : true});     //创建渲染器（并设置抗锯齿属性）
        renderer.setSize(width, height);    //设置渲染器的大小
        document.body.appendChild(renderer.domElement);     //添加渲染器的DOM元素到body中  
        const controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.screenSpacePanning = true;
        window.addEventListener('resize', function(){
            renderer.setSize(window.innerWidth, window.innerHeight);
        })
        
        function animate(time) {
            stats.update();

            requestAnimationFrame( animate );
            renderer.render(scene, camera);

        }
        animate();  
        </script>  
    </body>  
</html>  